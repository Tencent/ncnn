// Copyright 2026 Futz12 <pchar.cn>
// SPDX-License-Identifier: BSD-3-Clause

#version 450

layout(binding = 0) readonly buffer src_blob { sfpvec4 src_blob_data[]; };
layout(binding = 1) writeonly buffer dst_blob { sfpvec4 dst_blob_data[]; };

layout(push_constant) uniform parameter
{
    int src_w;
    int src_h;
    int channels;
    int outw;
    int outh;
    int kernel_w;
    int kernel_h;
    int dilation_w;
    int dilation_h;
    int stride_w;
    int stride_h;
    int src_cstep;
} p;

afp lane_get(afpvec4 v, int lane)
{
    if (lane == 0) return v.x;
    if (lane == 1) return v.y;
    if (lane == 2) return v.z;
    return v.w;
}

void main()
{
    int t = int(gl_GlobalInvocationID.x);
    int r4 = int(gl_GlobalInvocationID.y);

    int size = p.outw * p.outh;
    int maxk = p.kernel_w * p.kernel_h;
    int out_h = maxk * p.channels;
    int out_h4 = out_h / 4;

    if (t >= size || r4 >= out_h4)
        return;

    int i = t / p.outw;
    int j = t - i * p.outw;

    int base_sy = i * p.stride_h;
    int base_sx = j * p.stride_w;

    int r = r4 * 4;

    int pch = r / maxk;
    int k = r - pch * maxk;

    int u = k / p.kernel_w;
    int v = k - u * p.kernel_w;

    afpvec4 outv;

    for (int lane_out = 0; lane_out < 4; lane_out++)
    {
        int sy = u * p.dilation_h + base_sy;
        int sx = v * p.dilation_w + base_sx;

        int pch4 = pch >> 2;
        int lane_in = pch & 3;

        int si4 = pch4 * p.src_cstep + sy * p.src_w + sx;
        afpvec4 vv = buffer_ld4(src_blob_data, si4);
        afp val = lane_get(vv, lane_in);

        if (lane_out == 0) outv.x = val;
        else if (lane_out == 1) outv.y = val;
        else if (lane_out == 2) outv.z = val;
        else outv.w = val;

        v++;
        if (v == p.kernel_w)
        {
            v = 0;
            u++;
            if (u == p.kernel_h)
            {
                u = 0;
                pch++;
            }
        }
    }

    int di = r4 * size + t;
    buffer_st4(dst_blob_data, di, outv);
}