// Copyright 2026 Futz12 <pchar.cn>
// SPDX-License-Identifier: BSD-3-Clause

#version 450

layout (constant_id = 0) const int pooling_type = 0;
layout (constant_id = 1) const int kernel_w = 0;
layout (constant_id = 2) const int kernel_h = 0;
layout (constant_id = 3) const int stride_w = 1;
layout (constant_id = 4) const int stride_h = 1;
layout (constant_id = 5) const int pad_left = 0;
layout (constant_id = 6) const int pad_right = 0;
layout (constant_id = 7) const int pad_top = 0;
layout (constant_id = 8) const int pad_bottom = 0;
layout (constant_id = 9) const int pad_mode = 0;
layout (constant_id = 10) const int avgpool_count_include_pad = 0;

#define shape_constant_id_offset 11
layout (constant_id = shape_constant_id_offset + 0) const int dims = 0;
layout (constant_id = shape_constant_id_offset + 1) const int w = 0;
layout (constant_id = shape_constant_id_offset + 2) const int h = 0;
layout (constant_id = shape_constant_id_offset + 3) const int d = 0;
layout (constant_id = shape_constant_id_offset + 4) const int c = 0;
layout (constant_id = shape_constant_id_offset + 5) const int cstep = 0;

layout (constant_id = shape_constant_id_offset + 6) const int outdims = 0;
layout (constant_id = shape_constant_id_offset + 7) const int outw = 0;
layout (constant_id = shape_constant_id_offset + 8) const int outh = 0;
layout (constant_id = shape_constant_id_offset + 9) const int outd = 0;
layout (constant_id = shape_constant_id_offset + 10) const int outc = 0;
layout (constant_id = shape_constant_id_offset + 11) const int outcstep = 0;

layout (binding = 0) readonly buffer bottom_blob { sfp bottom_blob_data[]; };
layout (binding = 1) writeonly buffer top_blob { sfp top_blob_data[]; };

layout (push_constant) uniform parameter
{
    int dims;
    int w;
    int h;
    int d;
    int c;
    int cstep;

    int outdims;
    int outw;
    int outh;
    int outd;
    int outc;
    int outcstep;
} p;

const int tile_out_w = 8;
const int tile_out_h = 8;
const int tile_in_max = 36;

shared lfp tile[tile_in_max][tile_in_max];

void main()
{
    int lid_x = int(gl_LocalInvocationID.x);
    int lid_y = int(gl_LocalInvocationID.y);

    int gx0 = int(gl_WorkGroupID.x) * tile_out_w;
    int gy0 = int(gl_WorkGroupID.y) * tile_out_h;
    int gz = int(gl_GlobalInvocationID.z);

    if (gz >= psc(outc))
    return;

    int pl;
    int pr;
    int pt;
    int pb;

    if (pad_mode == 0 || pad_mode == 1)
    {
        pl = pad_left;
        pr = pad_right;
        pt = pad_top;
        pb = pad_bottom;

        if (pad_mode == 0)
        {
            int wtail = (psc(w) + pl + pr - kernel_w) % stride_w;
            int htail = (psc(h) + pt + pb - kernel_h) % stride_h;
            if (wtail != 0) pr += stride_w - wtail;
            if (htail != 0) pb += stride_h - htail;
        }
    }
    else
    {
        int wpad = kernel_w + (psc(w) - 1) / stride_w * stride_w - psc(w);
        int hpad = kernel_h + (psc(h) - 1) / stride_h * stride_h - psc(h);
        if (wpad < 0) wpad = 0;
        if (hpad < 0) hpad = 0;

        if (pad_mode == 2)
        {
            pl = wpad / 2;
            pr = wpad - pl;
            pt = hpad / 2;
            pb = hpad - pt;
        }
        else
        {
            pl = wpad - wpad / 2;
            pr = wpad / 2;
            pt = hpad - hpad / 2;
            pb = hpad / 2;
        }
    }

    int tile_in_w = (tile_out_w - 1) * stride_w + kernel_w;
    int tile_in_h = (tile_out_h - 1) * stride_h + kernel_h;

    int in_x0 = gx0 * stride_w - pl;
    int in_y0 = gy0 * stride_h - pt;

    lfp padv = (pooling_type == 0) ? sfp2lfp(afp(-3.402823466e38)) : sfp2lfp(afp(0.f));

    int l = lid_y * tile_out_w + lid_x;
    int lsize = tile_out_w * tile_out_h;
    int tilesz = tile_in_w * tile_in_h;

    for (int i = l; i < tilesz; i += lsize)
    {
        int ty = i / tile_in_w;
        int tx = i - ty * tile_in_w;

        int ix = in_x0 + tx;
        int iy = in_y0 + ty;

        lfp v = padv;
        if (ix >= 0 && ix < psc(w) && iy >= 0 && iy < psc(h))
        {
            int si = gz * psc(cstep) + iy * psc(w) + ix;
            v = sfp2lfp(buffer_ld1(bottom_blob_data, si));
        }

        tile[ty][tx] = v;
    }

    barrier();

    int ox = gx0 + lid_x;
    int oy = gy0 + lid_y;

    if (ox >= psc(outw) || oy >= psc(outh))
    return;

    int tx0 = lid_x * stride_w;
    int ty0 = lid_y * stride_h;

    afp outv;

    if (pooling_type == 0)
    {
        afp mv = lfp2afp(tile[ty0][tx0]);

        for (int ky = 0; ky < kernel_h; ky++)
        {
            for (int kx = 0; kx < kernel_w; kx++)
            {
                afp v = lfp2afp(tile[ty0 + ky][tx0 + kx]);
                mv = max(mv, v);
            }
        }

        outv = mv;
    }
    else
    {
        afp sum = afp(0.f);

        if (avgpool_count_include_pad == 1)
        {
            for (int ky = 0; ky < kernel_h; ky++)
            {
                for (int kx = 0; kx < kernel_w; kx++)
                {
                    sum += lfp2afp(tile[ty0 + ky][tx0 + kx]);
                }
            }

            sum *= afp(1.f / float(kernel_w * kernel_h));
            outv = sum;
        }
        else
        {
            int inx0 = ox * stride_w - pl;
            int iny0 = oy * stride_h - pt;

            int vx0 = max(0, -inx0);
            int vy0 = max(0, -iny0);
            int vx1 = min(kernel_w, psc(w) - inx0);
            int vy1 = min(kernel_h, psc(h) - iny0);

            int area = (vx1 - vx0) * (vy1 - vy0);
            if (area <= 0)
            {
                outv = afp(0.f);
            }
            else
            {
                for (int ky = vy0; ky < vy1; ky++)
                {
                    for (int kx = vx0; kx < vx1; kx++)
                    {
                        sum += lfp2afp(tile[ty0 + ky][tx0 + kx]);
                    }
                }

                sum *= afp(1.f / float(area));
                outv = sum;
            }
        }
    }

    int gi = gz * psc(outcstep) + oy * psc(outw) + ox;
    buffer_st1(top_blob_data, gi, outv);
}
