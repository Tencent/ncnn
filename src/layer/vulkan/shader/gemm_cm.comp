// Copyright 2025 Tencent
// SPDX-License-Identifier: BSD-3-Clause

#version 450

#extension GL_EXT_control_flow_attributes: require

#extension GL_KHR_shader_subgroup_basic: require

#extension GL_KHR_memory_scope_semantics: require
#extension GL_EXT_shader_explicit_arithmetic_types: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#if ncnn_VK_KHR_cooperative_matrix
#extension GL_KHR_cooperative_matrix: require
#elif ncnn_VK_NV_cooperative_matrix
#extension GL_NV_cooperative_matrix: require
#endif

layout (constant_id = 0) const float alpha = 1.f;
layout (constant_id = 1) const float beta = 1.f;
layout (constant_id = 2) const int transA = 0;
layout (constant_id = 3) const int transB = 0;
layout (constant_id = 4) const int constantA = 0;
layout (constant_id = 5) const int constantB = 0;
layout (constant_id = 6) const int constantC = 0;
layout (constant_id = 7) const int GM = 0;
layout (constant_id = 8) const int GN = 0;
layout (constant_id = 9) const int GK = 0;
layout (constant_id = 10) const int constant_broadcast_type_C = 0;
layout (constant_id = 11) const int output_N1M = 0;
layout (constant_id = 12) const int output_elempack = 0;
layout (constant_id = 13) const int output_elemtype = 0;
layout (constant_id = 14) const int output_transpose = 0;

layout (constant_id = 15) const uint M = 1;
layout (constant_id = 16) const uint N = 1;
layout (constant_id = 17) const uint K = 1;
layout (constant_id = 18) const uint UNROLL_SG_M = 2;
layout (constant_id = 19) const uint UNROLL_SG_N = 2;
layout (constant_id = 20) const uint UNROLL_SG_K = 2;
layout (constant_id = 21) const uint UNROLL_WG_M = 2;
layout (constant_id = 22) const uint UNROLL_WG_N = 2;

// TODO psc more

// layout (binding = 0) writeonly buffer top_blob { uvec2 top_blob_data[]; };
layout (binding = 0) writeonly buffer top_blob { float16_t top_blob_data[]; };
layout (binding = 1) readonly buffer A_blob { uvec2 A_blob_data[]; };
layout (binding = 2) readonly buffer B_blob { uvec2 B_blob_data[]; };
layout (binding = 3) readonly buffer C_blob { uvec2 C_blob_data[]; };

layout (push_constant) uniform parameter
{
    int GM;
    int GN;
    int GK;
    int broadcast_type_C;
    int A_dims;
    int A_hstep;
    int B_dims;
    int B_hstep;
    int outdims;
    int outhstep;
} p;

shared uvec2 tmp_a[UNROLL_WG_M][UNROLL_SG_M * UNROLL_SG_K * M * K / 4];

shared uvec2 tmp_b[UNROLL_WG_N][UNROLL_SG_N * UNROLL_SG_K * K * N / 4];

shared uvec2 tmp_o[UNROLL_WG_N * UNROLL_WG_M][UNROLL_SG_N * UNROLL_SG_M * M * N / 4];

void main()
{
    // assert gl_WorkGroupSize.x == gl_SubgroupSize
    // but neither gl_SubgroupSize nor gl_WorkGroupSize.x is a constant
    const uint local_size = ncnn_subgroupSize * UNROLL_WG_M * UNROLL_WG_N;

    // [ WG_UN * WG_UM * [ SG_UN * SG_UM * subgroup ] ]

    //                     <----WG_UN---->
    //       +---N--+-SG_UN+------+------+
    //       |      |      |      |XXXXXX|
    //       M             |       XXXX<----coopmat<M,N>
    //       |      |      |      |XXXXXX|
    //       +-- --SG0-- --+-- --SG2-- --+
    //       |      |      |      |      |
    //      SG_UM          |             |
    //       |      |      |      |      |
    //    ^  +------+--WORKGROUP--+------+
    //    |  |      |      |      |      |
    //    |  |             |             |
    //    |  |      |      |      |      |
    //  WG_UM+-- --SG1-- --+-- --SG3-- --+
    //    |  |      |      |      |      |
    //    |  |             |             |
    //    |  |      |      |      |      |
    //    v  +------+------+------+------+
    //

    const uint wgi = gl_WorkGroupID.x;
    const uint sgi = gl_SubgroupID;

    const uint wgmm = (psc(GM) + M * UNROLL_SG_M * UNROLL_WG_M - 1) / (M * UNROLL_SG_M * UNROLL_WG_M);
    const uint wgnn = (psc(GN) + N * UNROLL_SG_N * UNROLL_WG_N - 1) / (N * UNROLL_SG_N * UNROLL_WG_N);

    const uint wgmi = wgi / wgnn;
    const uint wgni = wgi % wgnn;

    const uint sgmi = sgi / UNROLL_WG_N;
    const uint sgni = sgi % UNROLL_WG_N;

//     const uint mm = (psc(GM) + M - 1) / M;
//     const uint nn = (psc(GN) + N - 1) / N;
    const uint kk = (psc(GK) + K - 1) / K;

    if (wgmi >= wgmm)
        return;

    const uint li = gl_LocalInvocationID.x;
    const uint si = gl_SubgroupInvocationID;

    const uint Md4 = M / 4;
    const uint Nd4 = N / 4;
    const uint Kd4 = K / 4;

    const uint ni = (wgni * UNROLL_WG_N + sgni) * UNROLL_SG_N;
    const uint mi = (wgmi * UNROLL_WG_M + sgmi) * UNROLL_SG_M;

#if ncnn_VK_KHR_cooperative_matrix
    coopmat<afp, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> sum[UNROLL_SG_N][UNROLL_SG_M];
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
    fcoopmatNV<16, gl_ScopeSubgroup, M, N> sum[UNROLL_SG_N][UNROLL_SG_M];
#else
    fcoopmatNV<32, gl_ScopeSubgroup, M, N> sum[UNROLL_SG_N][UNROLL_SG_M];
#endif
#endif

    {
        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
#if ncnn_VK_KHR_cooperative_matrix
                sum[zn][zm] = coopmat<afp, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(0.f);
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
                sum[zn][zm] = fcoopmatNV<16, gl_ScopeSubgroup, M, N>(0.f);
#else
                sum[zn][zm] = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(0.f);
#endif
#endif
            }
        }
    }

    const int broadcast_type_C = constantC == 1 ? constant_broadcast_type_C : p.broadcast_type_C;

    if (broadcast_type_C == 0)
    {
        afp bias_value = afp(unpackHalf2x16(C_blob_data[0].r)[0]);

        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
#if ncnn_VK_KHR_cooperative_matrix
                sum[zn][zm] = coopmat<afp, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(bias_value);
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
                sum[zn][zm] = fcoopmatNV<16, gl_ScopeSubgroup, M, N>(bias_value);
#else
                sum[zn][zm] = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(bias_value);
#endif
#endif
            }
        }
    }
    if (broadcast_type_C == 1 || broadcast_type_C == 2)
    {
        [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
        {
#if ncnn_VK_KHR_cooperative_matrix
            coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> bias;
            coopMatLoad(bias, C_blob_data, ((wgmi * UNROLL_WG_M + sgmi) * UNROLL_SG_M + zm) * Md4, 0, gl_CooperativeMatrixLayoutColumnMajor);
#elif ncnn_VK_NV_cooperative_matrix
            fcoopmatNV<16, gl_ScopeSubgroup, M, N> bias;
            coopMatLoadNV(bias, C_blob_data, ((wgmi * UNROLL_WG_M + sgmi) * UNROLL_SG_M + zm) * Md4, 0, true);
#endif

            [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
            {
#if NCNN_fp16_arithmetic
                sum[zn][zm] = bias;
#else
#if ncnn_VK_KHR_cooperative_matrix
                sum[zn][zm] = coopmat<float, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(bias);
#elif ncnn_VK_NV_cooperative_matrix
                sum[zn][zm] = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(bias);
#endif
#endif
            }
        }
    }
    if (broadcast_type_C == 3)
    {
        const uint Md4_N_USGM_USGN = Md4 * N * UNROLL_SG_M * UNROLL_SG_N;
        const uint Md4_N_USGM_USGN_d_subgroupsize = (Md4_N_USGM_USGN + ncnn_subgroupSize - 1) / ncnn_subgroupSize;
        [[unroll]] for (uint q = 0; q < Md4_N_USGM_USGN_d_subgroupsize; q++)
        {
            const uint siq = si + q * ncnn_subgroupSize;

            if (Md4_N_USGM_USGN % ncnn_subgroupSize == 0 || siq < Md4_N_USGM_USGN)
            {
                const uint zn = siq / (Md4 * N * UNROLL_SG_M);
                const uint zmij = siq % (Md4 * N * UNROLL_SG_M);
                const uint zm = zmij / (Md4 * N);
                const uint ij = zmij % (Md4 * N);
                const uint i = ij / Md4;
                const uint j = ij % Md4;

                const uint gn = (ni + zn) * N + i;
                const uint gm = (mi + zm) * Md4 + j;

                if (gn < psc(GN))
                {
                    const uvec4 gm4 = gm * 4 + uvec4(0, 1, 2, 3);

                    const uvec4 ci4 = gm4 * psc(GN) + gn;
                    const uvec4 ci4d4 = ci4 / 4;
                    const uvec4 ci4m4d2 = (ci4 % 4) / 2;
                    const uvec4 ci4m2 = ci4 % 2;

                    vec4 v = vec4(0.f);
                    if (gm4.r < psc(GM)) v.r = unpackHalf2x16(C_blob_data[ci4d4.r][ci4m4d2.r])[ci4m2.r];
                    if (gm4.g < psc(GM)) v.g = unpackHalf2x16(C_blob_data[ci4d4.g][ci4m4d2.g])[ci4m2.g];
                    if (gm4.b < psc(GM)) v.b = unpackHalf2x16(C_blob_data[ci4d4.b][ci4m4d2.b])[ci4m2.b];
                    if (gm4.a < psc(GM)) v.a = unpackHalf2x16(C_blob_data[ci4d4.a][ci4m4d2.a])[ci4m2.a];

                    tmp_o[sgi][siq] = uvec2(packHalf2x16(v.rg),packHalf2x16(v.ba));
                }
//                 if (gn < psc(GN) && gm < psc(GM))
//                 {
//                     const uint ci = gm * psc(GN) + gn;
//
//                     tmp_o[sgi][siq] = C_blob_data[ci];
//                 }
            }
        }

        barrier();

        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
#if ncnn_VK_KHR_cooperative_matrix
#if NCNN_fp16_arithmetic
                coopMatLoad(sum[zn][zm], tmp_o[sgi], (zn * UNROLL_SG_M + zm) * (Md4 * N), Md4, gl_CooperativeMatrixLayoutColumnMajor);
#else
                coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> sum_fp16;
                coopMatLoad(sum_fp16, tmp_o[sgi], (zn * UNROLL_SG_M + zm) * (Md4 * N), Md4, gl_CooperativeMatrixLayoutColumnMajor);
                sum[zn][zm] = coopmat<float, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(sum_fp16);
#endif
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
                coopMatLoadNV(sum[zn][zm], tmp_o[sgi], (zn * UNROLL_SG_M + zm) * (Md4 * N), Md4, true);
#else
                fcoopmatNV<16, gl_ScopeSubgroup, M, N> sum_fp16;
                coopMatLoadNV(sum_fp16, tmp_o[sgi], (zn * UNROLL_SG_M + zm) * (Md4 * N), Md4, true);
                sum[zn][zm] = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(sum_fp16);
#endif
#endif
            }
        }
    }
    if (broadcast_type_C == 4)
    {
        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
#if ncnn_VK_KHR_cooperative_matrix
            coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> bias;
            coopMatLoad(bias, C_blob_data, ((wgni * UNROLL_WG_N + sgni) * UNROLL_SG_N + zn) * Nd4, 0, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
            fcoopmatNV<16, gl_ScopeSubgroup, M, N> bias;
            coopMatLoadNV(bias, C_blob_data, ((wgni * UNROLL_WG_N + sgni) * UNROLL_SG_N + zn) * Nd4, 0, false);
#endif

            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
#if NCNN_fp16_arithmetic
                sum[zn][zm] = bias;
#else
#if ncnn_VK_KHR_cooperative_matrix
                sum[zn][zm] = coopmat<float, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(bias);
#elif ncnn_VK_NV_cooperative_matrix
                sum[zn][zm] = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(bias);
#endif
#endif
            }
        }
    }

    if (beta != 1.f)
    {
        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
                sum[zn][zm] = sum[zn][zm] * afp(beta);
            }
        }
    }

    uint k = 0;

#if 1
    for (; k < kk; k++)
    {
        const uint ki = k * K;

        barrier();

        // load A
        {
            if (transA == 0)
            {
                //      +-K-+
                //      M   |
                //      +SG_UM
                //      |   |
                //   ^  +---+
                //   |  |   |
                // WG_UM+- -+
                //   |  |   |
                //   v  +---+

                const uint Kd4_M_USGM = Kd4 * M * UNROLL_SG_M;
                const uint Kd4_M_USGM_d_subgroupsize = (Kd4_M_USGM + (ncnn_subgroupSize * UNROLL_WG_N - 1)) / (ncnn_subgroupSize * UNROLL_WG_N);
                [[unroll]] for (uint q = 0; q < Kd4_M_USGM_d_subgroupsize; q++)
                {
                    const uint siq = (q * UNROLL_WG_N + sgni) * ncnn_subgroupSize + si;

                    if (Kd4_M_USGM % (ncnn_subgroupSize * UNROLL_WG_N) == 0 || siq < Kd4_M_USGM)
                    {
                        const uint zm = siq / (Kd4 * M);
                        const uint ij = siq % (Kd4 * M);
                        const uint j = ij / Kd4;
                        const uint i = ij % Kd4;

                        const uint gk = ki / 4 + i;
                        const uint gm = (mi + zm) * M + j;

                        uvec2 v = uvec2(0);

                        // FIXME
                        if (gm < psc(GM))
                        {
                            if (p.A_hstep % 4 == 0)
                            {
                            const uint ai = gm * (p.A_hstep / 4) + gk;

                            v = A_blob_data[ai];

                            const uvec4 gk4 = gk * 4 + uvec4(0, 1, 2, 3);

                            uvec4 mask4 = uvec4(lessThan(gk4, uvec4(psc(GK)))) * 0xFFFFu;
                            uvec2 packed_mask = uvec2(mask4.x | (mask4.y << 16), mask4.z | (mask4.w << 16));

                            v = v & packed_mask;
                            }
                            else
                            {

                            vec4 v4 = vec4(0.f);

                            const uvec4 gk4 = gk * 4 + uvec4(0, 1, 2, 3);

                            const uvec4 ai4 = gm * p.A_hstep + gk4;
                            const uvec4 ai4d4 = ai4 / 4;
                            const uvec4 ai4m4d2 = (ai4 % 4) / 2;
                            const uvec4 ai4m2 = ai4 % 2;

                            if (gk4.r < psc(GK)) v4.r = unpackHalf2x16(A_blob_data[ai4d4.r][ai4m4d2.r])[ai4m2.r];
                            if (gk4.g < psc(GK)) v4.g = unpackHalf2x16(A_blob_data[ai4d4.g][ai4m4d2.g])[ai4m2.g];
                            if (gk4.b < psc(GK)) v4.b = unpackHalf2x16(A_blob_data[ai4d4.b][ai4m4d2.b])[ai4m2.b];
                            if (gk4.a < psc(GK)) v4.a = unpackHalf2x16(A_blob_data[ai4d4.a][ai4m4d2.a])[ai4m2.a];

                            v = uvec2(packHalf2x16(v4.rg),packHalf2x16(v4.ba));
                            }
                        }

                        tmp_a[sgmi][siq] = v;

                    }
                }
            }
            else
            {

                //      +-M-+
                //      K   |
                //      +SG_UM
                //      |   |
                //   ^  +---+
                //   |  |   |
                // WG_UM+- -+
                //   |  |   |
                //   v  +---+

                const uint Md4_K_USGM = Md4 * K * UNROLL_SG_M;
                const uint Md4_K_USGM_d_subgroupsize = (Md4_K_USGM + (ncnn_subgroupSize * UNROLL_WG_N - 1)) / (ncnn_subgroupSize * UNROLL_WG_N);
                [[unroll]] for (uint q = 0; q < Md4_K_USGM_d_subgroupsize; q++)
                {
                    const uint siq = (q * UNROLL_WG_N + sgni) * ncnn_subgroupSize + si;

                    if (Md4_K_USGM % (ncnn_subgroupSize * UNROLL_WG_N) == 0 || siq < Md4_K_USGM)
                    {
                        const uint zm = siq / (Md4 * K);
                        const uint ij = siq % (Md4 * K);
                        const uint i = ij / Md4;
                        const uint j = ij % Md4;

                        const uint gk = ki + i;
                        const uint gm = (mi + zm) * Md4 + j;

                        // FIXME
                        vec4 v = vec4(0.f);
                        if (gk < psc(GK))
                        {
                            const uvec4 gm4 = gm * 4 + uvec4(0, 1, 2, 3);

                            const uvec4 ai4 = gk * p.A_hstep + gm4;
                            const uvec4 ai4d4 = ai4 / 4;
                            const uvec4 ai4m4d2 = (ai4 % 4) / 2;
                            const uvec4 ai4m2 = ai4 % 2;

                            if (gm4.r < psc(GM)) v.r = unpackHalf2x16(A_blob_data[ai4d4.r][ai4m4d2.r])[ai4m2.r];
                            if (gm4.g < psc(GM)) v.g = unpackHalf2x16(A_blob_data[ai4d4.g][ai4m4d2.g])[ai4m2.g];
                            if (gm4.b < psc(GM)) v.b = unpackHalf2x16(A_blob_data[ai4d4.b][ai4m4d2.b])[ai4m2.b];
                            if (gm4.a < psc(GM)) v.a = unpackHalf2x16(A_blob_data[ai4d4.a][ai4m4d2.a])[ai4m2.a];
                        }

                        tmp_a[sgmi][siq] = uvec2(packHalf2x16(v.rg),packHalf2x16(v.ba));

//                         const uint ai = transA == 0 ? gm * p.A_hstep + gk : gk * p.A_hstep + gm;
//
//                         tmp_a[sgmi][siq] = gk < psc(GK) && gm < psc(GM) ? A_blob_data[ai] : float16_t(0.f);
                    }
                }

            }
        }

        // load B
        {
            if (transB == 0)
            {
            //      +-N-+
            //      K   |
            //      +SG_UN
            //      |   |
            //   ^  +---+
            //   |  |   |
            // WG_UN+- -+
            //   |  |   |
            //   v  +---+

            const uint Nd4_K_USGN = Nd4 * K * UNROLL_SG_N;
            const uint Nd4_K_USGN_d_subgroupsize = (Nd4_K_USGN + (ncnn_subgroupSize * UNROLL_WG_M - 1)) / (ncnn_subgroupSize * UNROLL_WG_M);
            [[unroll]] for (uint q = 0; q < Nd4_K_USGN_d_subgroupsize; q++)
            {
                const uint siq = (q * UNROLL_WG_M + sgmi) * ncnn_subgroupSize + si;

                if (Nd4_K_USGN % (ncnn_subgroupSize * UNROLL_WG_M) == 0 || siq < Nd4_K_USGN)
                {
                    const uint zn = siq / (Nd4 * K);
                    const uint ij = siq % (Nd4 * K);
                    const uint i = ij / Nd4;
                    const uint j = ij % Nd4;

                    const uint gk = ki + i;
                    const uint gn = (ni + zn) * Nd4 + j;

                    uvec2 v = uvec2(0);

                    // FIXME
                    if (gk < psc(GK))
                    {
                        if (p.B_hstep % 4 == 0)
                        {
                        const uint bi = gk * (p.B_hstep / 4) + gn;

                        v = B_blob_data[bi];

                        const uvec4 gn4 = gn * 4 + uvec4(0, 1, 2, 3);

                        uvec4 mask4 = uvec4(lessThan(gn4, uvec4(psc(GN)))) * 0xFFFFu;
                        uvec2 packed_mask = uvec2(mask4.x | (mask4.y << 16), mask4.z | (mask4.w << 16));

                        v = v & packed_mask;
                        }
                        else
                        {

                        vec4 v4 = vec4(0.f);
                        const uvec4 gn4 = gn * 4 + uvec4(0, 1, 2, 3);

                        const uvec4 bi4 = gk * p.B_hstep + gn4;
                        const uvec4 bi4d4 = bi4 / 4;
                        const uvec4 bi4m4d2 = (bi4 % 4) / 2;
                        const uvec4 bi4m2 = bi4 % 2;

                        if (gn4.r < psc(GN)) v4.r = unpackHalf2x16(B_blob_data[bi4d4.r][bi4m4d2.r])[bi4m2.r];
                        if (gn4.g < psc(GN)) v4.g = unpackHalf2x16(B_blob_data[bi4d4.g][bi4m4d2.g])[bi4m2.g];
                        if (gn4.b < psc(GN)) v4.b = unpackHalf2x16(B_blob_data[bi4d4.b][bi4m4d2.b])[bi4m2.b];
                        if (gn4.a < psc(GN)) v4.a = unpackHalf2x16(B_blob_data[bi4d4.a][bi4m4d2.a])[bi4m2.a];

                        v = uvec2(packHalf2x16(v4.rg),packHalf2x16(v4.ba));

                        }
                    }

                    tmp_b[sgni][siq] = v;

//                     const uint bi = transB == 1 ? gn * p.B_hstep + gk : gk * p.B_hstep + gn;

//                     tmp_b[sgni][siq] = gk < psc(GK) && gn < psc(GN) ? B_blob_data[bi] : float16_t(0.f);
                }
            }
            }
            else
            {
            //      +-K-+
            //      N   |
            //      +SG_UN
            //      |   |
            //   ^  +---+
            //   |  |   |
            // WG_UN+- -+
            //   |  |   |
            //   v  +---+

            const uint Kd4_N_USGN = Kd4 * N * UNROLL_SG_N;
            const uint Kd4_N_USGN_d_subgroupsize = (Kd4_N_USGN + (ncnn_subgroupSize * UNROLL_WG_M - 1)) / (ncnn_subgroupSize * UNROLL_WG_M);
            [[unroll]] for (uint q = 0; q < Kd4_N_USGN_d_subgroupsize; q++)
            {
                const uint siq = (q * UNROLL_WG_M + sgmi) * ncnn_subgroupSize + si;

                if (Kd4_N_USGN % (ncnn_subgroupSize * UNROLL_WG_M) == 0 || siq < Kd4_N_USGN)
                {
                    const uint zn = siq / (Kd4 * N);
                    const uint ij = siq % (Kd4 * N);
                    const uint j = ij / Kd4;
                    const uint i = ij % Kd4;

                    const uint gk = ki / 4 + i;
                    const uint gn = (ni + zn) * N + j;

                    // FIXME
                    vec4 v = vec4(0.f);
                    if (gn < psc(GN))
                    {
                        const uvec4 gk4 = gk * 4 + uvec4(0, 1, 2, 3);

                        const uvec4 bi4 = gn * p.B_hstep + gk4;
                        const uvec4 bi4d4 = bi4 / 4;
                        const uvec4 bi4m4d2 = (bi4 % 4) / 2;
                        const uvec4 bi4m2 = bi4 % 2;

                        if (gk4.r < psc(GK)) v.r = unpackHalf2x16(B_blob_data[bi4d4.r][bi4m4d2.r])[bi4m2.r];
                        if (gk4.g < psc(GK)) v.g = unpackHalf2x16(B_blob_data[bi4d4.g][bi4m4d2.g])[bi4m2.g];
                        if (gk4.b < psc(GK)) v.b = unpackHalf2x16(B_blob_data[bi4d4.b][bi4m4d2.b])[bi4m2.b];
                        if (gk4.a < psc(GK)) v.a = unpackHalf2x16(B_blob_data[bi4d4.a][bi4m4d2.a])[bi4m2.a];
                    }

                    tmp_b[sgni][siq] = uvec2(packHalf2x16(v.rg),packHalf2x16(v.ba));

//                     const uint bi = transB == 1 ? gn * p.B_hstep + gk : gk * p.B_hstep + gn;

//                     tmp_b[sgni][siq] = gk < psc(GK) && gn < psc(GN) ? B_blob_data[bi] : float16_t(0.f);
                }
            }
            }
        }

        barrier();

#if ncnn_VK_KHR_cooperative_matrix
        coopmat<float16_t, gl_ScopeSubgroup, M, K, gl_MatrixUseA> A[UNROLL_SG_M];
        coopmat<float16_t, gl_ScopeSubgroup, K, N, gl_MatrixUseB> B[UNROLL_SG_N];
#elif ncnn_VK_NV_cooperative_matrix
        fcoopmatNV<16, gl_ScopeSubgroup, M, K> A[UNROLL_SG_M];
        fcoopmatNV<16, gl_ScopeSubgroup, K, N> B[UNROLL_SG_N];
#endif

        [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
        {
            if (transA == 0)
            {
#if ncnn_VK_KHR_cooperative_matrix
                coopMatLoad(A[zm], tmp_a[sgmi], zm * (Kd4 * M), Kd4, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
                coopMatLoadNV(A[zm], tmp_a[sgmi], zm * (Kd4 * M), Kd4, false);
#endif
            }
            else
            {
#if ncnn_VK_KHR_cooperative_matrix
                coopMatLoad(A[zm], tmp_a[sgmi], zm * (Md4 * K), Md4, gl_CooperativeMatrixLayoutColumnMajor);
#elif ncnn_VK_NV_cooperative_matrix
                coopMatLoadNV(A[zm], tmp_a[sgmi], zm * (Md4 * K), Md4, true);
#endif
            }
        }

        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
            if (transB == 0)
            {
#if ncnn_VK_KHR_cooperative_matrix
                coopMatLoad(B[zn], tmp_b[sgni], zn * (Nd4 * K), Nd4, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
                coopMatLoadNV(B[zn], tmp_b[sgni], zn * (Nd4 * K), Nd4, false);
#endif
            }
            else
            {
#if ncnn_VK_KHR_cooperative_matrix
                coopMatLoad(B[zn], tmp_b[sgni], zn * (Kd4 * N), Kd4, gl_CooperativeMatrixLayoutColumnMajor);
#elif ncnn_VK_NV_cooperative_matrix
                coopMatLoadNV(B[zn], tmp_b[sgni], zn * (Kd4 * N), Kd4, true);
#endif
            }
        }

        // sum += k * v
        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
#if ncnn_VK_KHR_cooperative_matrix
                sum[zn][zm] = coopMatMulAdd(A[zm], B[zn], sum[zn][zm]);
#elif ncnn_VK_NV_cooperative_matrix
                sum[zn][zm] = coopMatMulAddNV(A[zm], B[zn], sum[zn][zm]);
#endif
            }
        }
    }
#endif

    if (alpha != 1.f)
    {
        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
                sum[zn][zm] = sum[zn][zm] * afp(alpha);
            }
        }
    }

    [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
    {
        [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
        {
#if ncnn_VK_KHR_cooperative_matrix
#if NCNN_fp16_arithmetic
            coopMatStore(sum[zn][zm], tmp_o[sgi], (zn * UNROLL_SG_M + zm) * (Md4 * N), Md4, gl_CooperativeMatrixLayoutColumnMajor);
#else
            coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> sum_fp16 = coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(sum[zn][zm]);
            coopMatStore(sum_fp16, tmp_o[sgi], (zn * UNROLL_SG_M + zm) * (Md4 * N), Md4, gl_CooperativeMatrixLayoutColumnMajor);
#endif
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
            coopMatStoreNV(sum[zn][zm], tmp_o[sgi], (zn * UNROLL_SG_M + zm) * (Md4 * N), Md4, true);
#else
            fcoopmatNV<16, gl_ScopeSubgroup, M, N> sum_fp16 = fcoopmatNV<16, gl_ScopeSubgroup, M, N>(sum[zn][zm]);
            coopMatStoreNV(sum_fp16, tmp_o[sgi], (zn * UNROLL_SG_M + zm) * (Md4 * N), Md4, true);
#endif
#endif
        }
    }

    barrier();

    // store top_blob
    {
        //          +-M-+
        //          N   |
        //          +SG_UM
        //          |   |
        //       ^  +---+
        //       |  |   |
        //     SG_UN+- -+
        //       |  |   |
        //     ^ v  +---+
        //     |    |   |
        //     |    +- -+
        //     |    |   |
        //   WG_UM  +- -+
        //     |    |   |
        //     |    +- -+
        //     |    |   |
        //   ^ v    +---+
        //   |      |   |
        //   |      +- -+
        //   |      |   |
        //   |      +---+
        //   |      |   |
        //   |      +- -+
        //   |      |   |
        // WG_UN    +---+
        //   |      |   |
        //   |      +- -+
        //   |      |   |
        //   |      +---+
        //   |      |   |
        //   |      +- -+
        //   |      |   |
        //   v      +---+

        const uint Md4_N_USGM_USGN = Md4 * N * UNROLL_SG_M * UNROLL_SG_N;
        const uint Md4_N_USGM_USGN_d_subgroupsize = (Md4_N_USGM_USGN + ncnn_subgroupSize - 1) / ncnn_subgroupSize;
        [[unroll]] for (uint q = 0; q < Md4_N_USGM_USGN_d_subgroupsize; q++)
        {
            const uint siq = si + q * ncnn_subgroupSize;

            if (Md4_N_USGM_USGN % ncnn_subgroupSize == 0 || siq < Md4_N_USGM_USGN)
            {
                const uint zn = siq / (Md4 * N * UNROLL_SG_M);
                const uint zmij = siq % (Md4 * N * UNROLL_SG_M);
                const uint zm = zmij / (Md4 * N);
                const uint ij = zmij % (Md4 * N);
                const uint i = ij / Md4;
                const uint j = ij % Md4;

                const uint gn = (ni + zn) * N + i;
                const uint gm = (mi + zm) * Md4 + j;

                // FIXME
                if (gn < psc(GN))
                {
                    uvec2 v = tmp_o[sgi][siq];

                    vec2 va = unpackHalf2x16(v.r);
                    vec2 vb = unpackHalf2x16(v.g);

                    if (output_transpose == 0)
                    {
                        const uvec4 oi4 = (gm * 4 + uvec4(0, 1, 2, 3)) * p.outhstep + gn;

                        if (gm * 4 < psc(GM)) top_blob_data[oi4.r] = float16_t(va.r);
                        if (gm * 4 + 1 < psc(GM)) top_blob_data[oi4.g] = float16_t(va.g);
                        if (gm * 4 + 2 < psc(GM)) top_blob_data[oi4.b] = float16_t(vb.r);
                        if (gm * 4 + 3 < psc(GM)) top_blob_data[oi4.a] = float16_t(vb.g);
                    }
                    else
                    {
                        const uvec4 oi4 = gn * p.outhstep + (gm * 4 + uvec4(0, 1, 2, 3));

                        if (gm * 4 < psc(GM)) top_blob_data[oi4.r] = float16_t(va.r);
                        if (gm * 4 + 1 < psc(GM)) top_blob_data[oi4.g] = float16_t(va.g);
                        if (gm * 4 + 2 < psc(GM)) top_blob_data[oi4.b] = float16_t(vb.r);
                        if (gm * 4 + 3 < psc(GM)) top_blob_data[oi4.a] = float16_t(vb.g);
                    }
                }
//                 if (gn < psc(GN) && gm < psc(GM))
//                 {
//                     const uint oi = output_transpose == 0 ? gm * p.outhstep + gn : gn * p.outhstep + gm;
//
//                     top_blob_data[oi] = tmp_o[sgi][siq];
//                 }
            }
        }
    }
}
