// Copyright 2026 Tencent
// SPDX-License-Identifier: BSD-3-Clause

#version 450

#define LOCAL_MEMORY_UNROLL_INCH 8

layout(constant_id = 0) const int attn_mask = 0;
layout(constant_id = 1) const float scale = 0.f;
layout(constant_id = 2) const int M = 0;
layout(constant_id = 3) const int N = 0;
layout(constant_id = 4) const int K = 0;
layout(constant_id = 5) const int B = 0;
layout(constant_id = 6) const int transB = 0;
layout(constant_id = 7) const int attn_mask_dims = 0;
layout(constant_id = 8) const int num_heads_per_group = 0;
layout(constant_id = 9) const int A_cstep = 0;
layout(constant_id = 10) const int B_cstep = 0;
layout(constant_id = 11) const int out_cstep = 0;
layout(constant_id = 12) const int mask_cstep = 0;

layout(binding = 0) readonly buffer A_blob { sfpvec4 A_blob_data[]; };
layout(binding = 1) readonly buffer B_blob { sfpvec4 B_blob_data[]; };
layout(binding = 2) writeonly buffer top_blob { sfp top_blob_data[]; };
layout(binding = 3) readonly buffer mask_blob { sfp mask_blob_data[]; };

layout(push_constant) uniform parameter
{
    float scale;
    int M;
    int N;
    int K;
    int B;
    int attn_mask_dims;
    int num_heads_per_group;
    int A_cstep;
    int B_cstep;
    int out_cstep;
    int mask_cstep;
} p;

#if NCNN_shader_local_memory
// avoid bank conflict
#define PAD 1
shared lfpvec4 tmp_a[8][LOCAL_MEMORY_UNROLL_INCH + PAD];
shared lfpvec4 tmp_b[8][LOCAL_MEMORY_UNROLL_INCH + PAD];
#endif

void main()
{
    int gx = int(gl_GlobalInvocationID.x);
    int gy = int(gl_GlobalInvocationID.y);
    int gz = int(gl_GlobalInvocationID.z);

#if !NCNN_shader_local_memory
    if (gx * 4 >= psc(N) || gy * 4 >= psc(M) || gz >= psc(B))
        return;
#endif

    afpvec4 sum0 = afpvec4(0.f);
    afpvec4 sum1 = afpvec4(0.f);
    afpvec4 sum2 = afpvec4(0.f);
    afpvec4 sum3 = afpvec4(0.f);

#if NCNN_shader_local_memory
    const int NN = psc(K);

    const int lx = int(gl_LocalInvocationID.x);
    const int ly = int(gl_LocalInvocationID.y);

    int k = 0;
    for (; k + (LOCAL_MEMORY_UNROLL_INCH - 1) < NN; k += LOCAL_MEMORY_UNROLL_INCH)
    {
        {
            const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);
            const uvec4 ai4 = gz * psc(A_cstep) + gy4 * psc(K) + (k + lx);

            const uvec4 ai4d4 = ai4 / 4;
            const uvec4 ai4m4 = ai4 % 4;

            afpvec4 a;
            a.r = buffer_ld4(A_blob_data, ai4d4.r)[ai4m4.r];
            a.g = buffer_ld4(A_blob_data, ai4d4.g)[ai4m4.g];
            a.b = buffer_ld4(A_blob_data, ai4d4.b)[ai4m4.b];
            a.a = buffer_ld4(A_blob_data, ai4d4.a)[ai4m4.a];

            tmp_a[ly][lx] = afp2lfpvec4(a);
        }

        if (transB == 0)
        {
            if (psc(N) % 4 == 0)
            {
                const uint bi = (gz / psc(num_heads_per_group)) * psc(B_cstep) / 4 + (k + ly) * (psc(N) / 4) + gx;
                tmp_b[lx][ly] = buffer_sm4(B_blob_data, bi);
            }
            else
            {
                const uvec4 bi4 = (gz / psc(num_heads_per_group)) * psc(B_cstep) + (k + ly) * psc(N) + gx * 4 + uvec4(0, 1, 2, 3);

                const uvec4 bi4d4 = bi4 / 4;
                const uvec4 bi4m4 = bi4 % 4;

                afpvec4 b;
                b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
                b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
                b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
                b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];

                tmp_b[lx][ly] = afp2lfpvec4(b);
            }
        }
        else
        {
            const uvec4 gx4 = gx * 4 + uvec4(0, 1, 2, 3);
            const uvec4 bi4 = (gz / psc(num_heads_per_group)) * psc(B_cstep) + gx4 * psc(K) + (k + ly);

            const uvec4 bi4d4 = bi4 / 4;
            const uvec4 bi4m4 = bi4 % 4;

            afpvec4 b;
            b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
            b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
            b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
            b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];

            tmp_b[lx][ly] = afp2lfpvec4(b);
        }

        barrier();

        for (int k4 = 0; k4 < LOCAL_MEMORY_UNROLL_INCH; k4++)
        {
            afpvec4 a = lfp2afpvec4(tmp_a[ly][k4]);

            afpvec4 b = lfp2afpvec4(tmp_b[lx][k4]);

            sum0 += a.r * b;
            sum1 += a.g * b;
            sum2 += a.b * b;
            sum3 += a.a * b;
        }

        barrier();
    }

    if (k < NN)
    {
        const int remain = NN - k;

        if (lx < remain)
        {
            const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);
            const uvec4 ai4 = gz * psc(A_cstep) + gy4 * psc(K) + (k + lx);

            const uvec4 ai4d4 = ai4 / 4;
            const uvec4 ai4m4 = ai4 % 4;

            afpvec4 a;
            a.r = buffer_ld4(A_blob_data, ai4d4.r)[ai4m4.r];
            a.g = buffer_ld4(A_blob_data, ai4d4.g)[ai4m4.g];
            a.b = buffer_ld4(A_blob_data, ai4d4.b)[ai4m4.b];
            a.a = buffer_ld4(A_blob_data, ai4d4.a)[ai4m4.a];

            tmp_a[ly][lx] = afp2lfpvec4(a);
        }

        if (ly < remain)
        {
            if (transB == 0)
            {
                if (psc(N) % 4 == 0)
                {
                    const uint bi = (gz / psc(num_heads_per_group)) * psc(B_cstep) / 4 + (k + ly) * (psc(N) / 4) + gx;
                    tmp_b[lx][ly] = buffer_sm4(B_blob_data, bi);
                }
                else
                {
                    const uvec4 bi4 = (gz / psc(num_heads_per_group)) * psc(B_cstep) + (k + ly) * psc(N) + gx * 4 + uvec4(0, 1, 2, 3);

                    const uvec4 bi4d4 = bi4 / 4;
                    const uvec4 bi4m4 = bi4 % 4;

                    afpvec4 b;
                    b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
                    b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
                    b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
                    b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];

                    tmp_b[lx][ly] = afp2lfpvec4(b);
                }
            }
            else
            {
                const uvec4 gx4 = gx * 4 + uvec4(0, 1, 2, 3);
                const uvec4 bi4 = (gz / psc(num_heads_per_group)) * psc(B_cstep) + gx4 * psc(K) + (k + ly);

                const uvec4 bi4d4 = bi4 / 4;
                const uvec4 bi4m4 = bi4 % 4;

                afpvec4 b;
                b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
                b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
                b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
                b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];

                tmp_b[lx][ly] = afp2lfpvec4(b);
            }
        }

        barrier();

        for (int k4 = 0; k4 < remain; k4++)
        {
            afpvec4 a = lfp2afpvec4(tmp_a[ly][k4]);

            afpvec4 b = lfp2afpvec4(tmp_b[lx][k4]);

            sum0 += a.r * b;
            sum1 += a.g * b;
            sum2 += a.b * b;
            sum3 += a.a * b;
        }
    }
#else
    for (int k = 0; k < psc(K); k++)
    {
        afpvec4 a;
        {
            const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);
            const uvec4 ai4 = gz * psc(A_cstep) + gy4 * psc(K) + k;

            const uvec4 ai4d4 = ai4 / 4;
            const uvec4 ai4m4 = ai4 % 4;

            a.r = buffer_ld4(A_blob_data, ai4d4.r)[ai4m4.r];
            a.g = buffer_ld4(A_blob_data, ai4d4.g)[ai4m4.g];
            a.b = buffer_ld4(A_blob_data, ai4d4.b)[ai4m4.b];
            a.a = buffer_ld4(A_blob_data, ai4d4.a)[ai4m4.a];
        }

        afpvec4 b;
        if (transB == 0)
        {
            if (psc(N) % 4 == 0)
            {
                const uint bi = (gz / psc(num_heads_per_group)) * psc(B_cstep) / 4 + k * (psc(N) / 4) + gx;
                b = buffer_ld4(B_blob_data, bi);
            }
            else
            {
                const uvec4 bi4 = (gz / psc(num_heads_per_group)) * psc(B_cstep) + k * psc(N) + gx * 4 + uvec4(0, 1, 2, 3);

                const uvec4 bi4d4 = bi4 / 4;
                const uvec4 bi4m4 = bi4 % 4;

                b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
                b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
                b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
                b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];
            }
        }
        else
        {
            const uvec4 gx4 = gx * 4 + uvec4(0, 1, 2, 3);
            const uvec4 bi4 = (gz / psc(num_heads_per_group)) * psc(B_cstep) + gx4 * psc(K) + k;

            const uvec4 bi4d4 = bi4 / 4;
            const uvec4 bi4m4 = bi4 % 4;

            b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
            b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
            b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
            b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];
        }

        sum0 += a.r * b;
        sum1 += a.g * b;
        sum2 += a.b * b;
        sum3 += a.a * b;
    }
#endif

#if NCNN_shader_local_memory
    if (gx * 4 >= psc(N) || gy * 4 >= psc(M) || gz >= psc(B))
        return;
#endif

    if (scale != 1.f)
    {
        sum0 *= afp(psc(scale));
        sum1 *= afp(psc(scale));
        sum2 *= afp(psc(scale));
        sum3 *= afp(psc(scale));
    }

    if (attn_mask == 1)
    {
        const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);
        uvec4 mi4 = gy4 * psc(N) + gx * 4;
        if (psc(attn_mask_dims) == 3)
        {
            mi4 += gz * psc(mask_cstep);
        }

        sum0.r += buffer_ld1(mask_blob_data, mi4.r + 0);
        sum0.g += buffer_ld1(mask_blob_data, mi4.r + 1);
        sum0.b += buffer_ld1(mask_blob_data, mi4.r + 2);
        sum0.a += buffer_ld1(mask_blob_data, mi4.r + 3);
        sum1.r += buffer_ld1(mask_blob_data, mi4.g + 0);
        sum1.g += buffer_ld1(mask_blob_data, mi4.g + 1);
        sum1.b += buffer_ld1(mask_blob_data, mi4.g + 2);
        sum1.a += buffer_ld1(mask_blob_data, mi4.g + 3);
        sum2.r += buffer_ld1(mask_blob_data, mi4.b + 0);
        sum2.g += buffer_ld1(mask_blob_data, mi4.b + 1);
        sum2.b += buffer_ld1(mask_blob_data, mi4.b + 2);
        sum2.a += buffer_ld1(mask_blob_data, mi4.b + 3);
        sum3.r += buffer_ld1(mask_blob_data, mi4.a + 0);
        sum3.g += buffer_ld1(mask_blob_data, mi4.a + 1);
        sum3.b += buffer_ld1(mask_blob_data, mi4.a + 2);
        sum3.a += buffer_ld1(mask_blob_data, mi4.a + 3);
    }

    {
        const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);
        const uvec4 gi4 = gz * psc(out_cstep) + gy4 * psc(N) + gx * 4;

        buffer_st1(top_blob_data, gi4.r, sum0.r);
        if (gx * 4 + 1 < psc(N)) buffer_st1(top_blob_data, gi4.r + 1, sum0.g);
        if (gx * 4 + 2 < psc(N)) buffer_st1(top_blob_data, gi4.r + 2, sum0.b);
        if (gx * 4 + 3 < psc(N)) buffer_st1(top_blob_data, gi4.r + 3, sum0.a);
        if (gy4.g < psc(M))
        {
            buffer_st1(top_blob_data, gi4.g, sum1.r);
            if (gx * 4 + 1 < psc(N)) buffer_st1(top_blob_data, gi4.g + 1, sum1.g);
            if (gx * 4 + 2 < psc(N)) buffer_st1(top_blob_data, gi4.g + 2, sum1.b);
            if (gx * 4 + 3 < psc(N)) buffer_st1(top_blob_data, gi4.g + 3, sum1.a);
        }
        if (gy4.b < psc(M))
        {
            buffer_st1(top_blob_data, gi4.b, sum2.r);
            if (gx * 4 + 1 < psc(N)) buffer_st1(top_blob_data, gi4.b + 1, sum2.g);
            if (gx * 4 + 2 < psc(N)) buffer_st1(top_blob_data, gi4.b + 2, sum2.b);
            if (gx * 4 + 3 < psc(N)) buffer_st1(top_blob_data, gi4.b + 3, sum2.a);
        }
        if (gy4.a < psc(M))
        {
            buffer_st1(top_blob_data, gi4.a, sum3.r);
            if (gx * 4 + 1 < psc(N)) buffer_st1(top_blob_data, gi4.a + 1, sum3.g);
            if (gx * 4 + 2 < psc(N)) buffer_st1(top_blob_data, gi4.a + 2, sum3.b);
            if (gx * 4 + 3 < psc(N)) buffer_st1(top_blob_data, gi4.a + 3, sum3.a);
        }
    }
}
