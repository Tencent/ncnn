// Copyright 2023 Tencent
// SPDX-License-Identifier: BSD-3-Clause

#version 450

#define LOCAL_MEMORY_UNROLL_INCH 8

layout(constant_id = 0) const float alpha = 1.f;
layout(constant_id = 1) const float beta = 1.f;
layout(constant_id = 2) const int transA = 0;
layout(constant_id = 3) const int transB = 0;
layout(constant_id = 4) const int constantA = 0;
layout(constant_id = 5) const int constantB = 0;
layout(constant_id = 6) const int constantC = 0;
layout(constant_id = 7) const int M = 0;
layout(constant_id = 8) const int N = 0;
layout(constant_id = 9) const int K = 0;
layout(constant_id = 10) const int constant_broadcast_type_C = 0;
layout(constant_id = 11) const int output_N1M = 0;
layout(constant_id = 12) const int output_elempack = 0;
layout(constant_id = 13) const int output_elemtype = 0;
layout(constant_id = 14) const int output_transpose = 0;

// TODO psc more

layout(binding = 0) writeonly buffer top_blob { sfp top_blob_data[]; };
layout(binding = 1) readonly buffer A_blob { sfpvec4 A_blob_data[]; };
layout(binding = 2) readonly buffer B_blob { sfpvec4 B_blob_data[]; };
layout(binding = 3) readonly buffer C_blob { sfp C_blob_data[]; };

layout(push_constant) uniform parameter
{
    int M;
    int N;
    int K;
    int broadcast_type_C;
    int A_dims;
    int A_hstep;
    int B_dims;
    int B_hstep;
    int outdims;
    int outhstep;
} p;

#if NCNN_shader_local_memory
// avoid bank conflict
#define PAD 1
shared lfpvec4 tmp_a[8][LOCAL_MEMORY_UNROLL_INCH + PAD];
shared lfpvec4 tmp_b[8][LOCAL_MEMORY_UNROLL_INCH + PAD];
#endif

void main()
{
    const uint gx = gl_GlobalInvocationID.x;
    const uint gy = gl_GlobalInvocationID.y;
    const uint gz = gl_GlobalInvocationID.z;

#if !NCNN_shader_local_memory
    if (gx * 4 >= psc(N) || gy * 4 >= psc(M) || gz >= 1)
        return;
#endif

    afpvec4 sum0 = afpvec4(0.f);
    afpvec4 sum1 = afpvec4(0.f);
    afpvec4 sum2 = afpvec4(0.f);
    afpvec4 sum3 = afpvec4(0.f);

    const int broadcast_type_C = constantC == 1 ? constant_broadcast_type_C : p.broadcast_type_C;

    if (broadcast_type_C == 0)
    {
        sum0 = afpvec4(buffer_ld1(C_blob_data, 0));
        sum1 = sum0;
        sum2 = sum0;
        sum3 = sum0;
    }
    if (broadcast_type_C == 1 || broadcast_type_C == 2)
    {
        const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);

        sum0 = afpvec4(buffer_ld1(C_blob_data, gy4.r));
        sum1 = afpvec4(buffer_ld1(C_blob_data, gy4.g));
        sum2 = afpvec4(buffer_ld1(C_blob_data, gy4.b));
        sum3 = afpvec4(buffer_ld1(C_blob_data, gy4.a));
    }
    if (broadcast_type_C == 3)
    {
        const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);
        const uvec4 ci4 = gy4 * psc(N) + gx * 4;

        sum0.r = buffer_ld1(C_blob_data, ci4.r + 0);
        sum0.g = buffer_ld1(C_blob_data, ci4.r + 1);
        sum0.b = buffer_ld1(C_blob_data, ci4.r + 2);
        sum0.a = buffer_ld1(C_blob_data, ci4.r + 3);
        sum1.r = buffer_ld1(C_blob_data, ci4.g + 0);
        sum1.g = buffer_ld1(C_blob_data, ci4.g + 1);
        sum1.b = buffer_ld1(C_blob_data, ci4.g + 2);
        sum1.a = buffer_ld1(C_blob_data, ci4.g + 3);
        sum2.r = buffer_ld1(C_blob_data, ci4.b + 0);
        sum2.g = buffer_ld1(C_blob_data, ci4.b + 1);
        sum2.b = buffer_ld1(C_blob_data, ci4.b + 2);
        sum2.a = buffer_ld1(C_blob_data, ci4.b + 3);
        sum3.r = buffer_ld1(C_blob_data, ci4.a + 0);
        sum3.g = buffer_ld1(C_blob_data, ci4.a + 1);
        sum3.b = buffer_ld1(C_blob_data, ci4.a + 2);
        sum3.a = buffer_ld1(C_blob_data, ci4.a + 3);
    }
    if (broadcast_type_C == 4)
    {
        const uvec4 gx4 = gx * 4 + uvec4(0, 1, 2, 3);

        sum0.r = buffer_ld1(C_blob_data, gx4.r);
        sum0.g = buffer_ld1(C_blob_data, gx4.g);
        sum0.b = buffer_ld1(C_blob_data, gx4.b);
        sum0.a = buffer_ld1(C_blob_data, gx4.a);
        sum1 = sum0;
        sum2 = sum0;
        sum3 = sum0;
    }

    if (beta != 1.f)
    {
        sum0 *= afp(beta);
        sum1 *= afp(beta);
        sum2 *= afp(beta);
        sum3 *= afp(beta);
    }

#if NCNN_shader_local_memory
    const int NN = psc(K);

    const uint lx = gl_LocalInvocationID.x;
    const uint ly = gl_LocalInvocationID.y;

    int k = 0;
    for (; k + (LOCAL_MEMORY_UNROLL_INCH - 1) < NN; k += LOCAL_MEMORY_UNROLL_INCH)
    {
        {
            if (transA == 1)
            {
                if (p.A_hstep % 4 == 0)
                {
                    const uint ai = (k + lx) * (p.A_hstep / 4) + gy;
                    tmp_a[ly][lx] = buffer_sm4(A_blob_data, ai);
                }
                else
                {
                    const uvec4 ai4 = (k + lx) * p.A_hstep + gy * 4 + uvec4(0, 1, 2, 3);

                    const uvec4 ai4d4 = ai4 / 4;
                    const uvec4 ai4m4 = ai4 % 4;

                    afpvec4 a;
                    a.r = buffer_ld4(A_blob_data, ai4d4.r)[ai4m4.r];
                    a.g = buffer_ld4(A_blob_data, ai4d4.g)[ai4m4.g];
                    a.b = buffer_ld4(A_blob_data, ai4d4.b)[ai4m4.b];
                    a.a = buffer_ld4(A_blob_data, ai4d4.a)[ai4m4.a];

                    tmp_a[ly][lx] = afp2lfpvec4(a);
                }
            }
            else
            {
                const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);
                const uvec4 ai4 = gy4 * p.A_hstep + (k + lx);

                const uvec4 ai4d4 = ai4 / 4;
                const uvec4 ai4m4 = ai4 % 4;

                afpvec4 a;
                a.r = buffer_ld4(A_blob_data, ai4d4.r)[ai4m4.r];
                a.g = buffer_ld4(A_blob_data, ai4d4.g)[ai4m4.g];
                a.b = buffer_ld4(A_blob_data, ai4d4.b)[ai4m4.b];
                a.a = buffer_ld4(A_blob_data, ai4d4.a)[ai4m4.a];

                tmp_a[ly][lx] = afp2lfpvec4(a);
            }

            if (transB == 1)
            {
                const uvec4 gx4 = gx * 4 + uvec4(0, 1, 2, 3);
                const uvec4 bi4 = gx4 * p.B_hstep + (k + ly);

                const uvec4 bi4d4 = bi4 / 4;
                const uvec4 bi4m4 = bi4 % 4;

                afpvec4 b;
                b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
                b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
                b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
                b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];

                tmp_b[lx][ly] = afp2lfpvec4(b);
            }
            else
            {
                if (p.B_hstep % 4 == 0)
                {
                    const uint bi = (k + ly) * (p.B_hstep / 4) + gx;
                    tmp_b[lx][ly] = buffer_sm4(B_blob_data, bi);
                }
                else
                {
                    const uvec4 bi4 = (k + ly) * p.B_hstep + gx * 4 + uvec4(0, 1, 2, 3);

                    const uvec4 bi4d4 = bi4 / 4;
                    const uvec4 bi4m4 = bi4 % 4;

                    afpvec4 b;
                    b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
                    b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
                    b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
                    b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];

                    tmp_b[lx][ly] = afp2lfpvec4(b);
                }
            }
        }

        barrier();

        for (int k4 = 0; k4 < LOCAL_MEMORY_UNROLL_INCH; k4++)
        {
            afpvec4 a = lfp2afpvec4(tmp_a[ly][k4]);

            afpvec4 b = lfp2afpvec4(tmp_b[lx][k4]);

            sum0 += a.r * b;
            sum1 += a.g * b;
            sum2 += a.b * b;
            sum3 += a.a * b;
        }

        barrier();
    }

    if (k < NN)
    {
        const int remain = NN - k;

        if (lx < remain)
        {
            if (transA == 1)
            {
                if (p.A_hstep % 4 == 0)
                {
                    const uint ai = (k + lx) * (p.A_hstep / 4) + gy;
                    tmp_a[ly][lx] = buffer_sm4(A_blob_data, ai);
                }
                else
                {
                    const uvec4 ai4 = (k + lx) * p.A_hstep + gy * 4 + uvec4(0, 1, 2, 3);

                    const uvec4 ai4d4 = ai4 / 4;
                    const uvec4 ai4m4 = ai4 % 4;

                    afpvec4 a;
                    a.r = buffer_ld4(A_blob_data, ai4d4.r)[ai4m4.r];
                    a.g = buffer_ld4(A_blob_data, ai4d4.g)[ai4m4.g];
                    a.b = buffer_ld4(A_blob_data, ai4d4.b)[ai4m4.b];
                    a.a = buffer_ld4(A_blob_data, ai4d4.a)[ai4m4.a];

                    tmp_a[ly][lx] = afp2lfpvec4(a);
                }
            }
            else
            {
                const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);
                const uvec4 ai4 = gy4 * p.A_hstep + (k + lx);

                const uvec4 ai4d4 = ai4 / 4;
                const uvec4 ai4m4 = ai4 % 4;

                afpvec4 a;
                a.r = buffer_ld4(A_blob_data, ai4d4.r)[ai4m4.r];
                a.g = buffer_ld4(A_blob_data, ai4d4.g)[ai4m4.g];
                a.b = buffer_ld4(A_blob_data, ai4d4.b)[ai4m4.b];
                a.a = buffer_ld4(A_blob_data, ai4d4.a)[ai4m4.a];

                tmp_a[ly][lx] = afp2lfpvec4(a);
            }
        }

        if (ly < remain)
        {
            if (transB == 1)
            {
                const uvec4 gx4 = gx * 4 + uvec4(0, 1, 2, 3);
                const uvec4 bi4 = gx4 * p.B_hstep + (k + ly);

                const uvec4 bi4d4 = bi4 / 4;
                const uvec4 bi4m4 = bi4 % 4;

                afpvec4 b;
                b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
                b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
                b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
                b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];

                tmp_b[lx][ly] = afp2lfpvec4(b);
            }
            else
            {
                if (p.B_hstep % 4 == 0)
                {
                    const uint bi = (k + ly) * (p.B_hstep / 4) + gx;
                    tmp_b[lx][ly] = buffer_sm4(B_blob_data, bi);
                }
                else
                {
                    const uvec4 bi4 = (k + ly) * p.B_hstep + gx * 4 + uvec4(0, 1, 2, 3);

                    const uvec4 bi4d4 = bi4 / 4;
                    const uvec4 bi4m4 = bi4 % 4;

                    afpvec4 b;
                    b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
                    b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
                    b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
                    b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];

                    tmp_b[lx][ly] = afp2lfpvec4(b);
                }
            }
        }

        barrier();

        for (int k4 = 0; k4 < remain; k4++)
        {
            afpvec4 a = lfp2afpvec4(tmp_a[ly][k4]);

            afpvec4 b = lfp2afpvec4(tmp_b[lx][k4]);

            sum0 += a.r * b;
            sum1 += a.g * b;
            sum2 += a.b * b;
            sum3 += a.a * b;
        }
    }
#else
    for (int k = 0; k < psc(K); k++)
    {
        afpvec4 a;
        if (transA == 1)
        {
            if (p.A_hstep % 4 == 0)
            {
                const uint ai = k * (p.A_hstep / 4) + gy;
                a = buffer_ld4(A_blob_data, ai);
            }
            else
            {
                const uvec4 ai4 = k * p.A_hstep + gy * 4 + uvec4(0, 1, 2, 3);

                const uvec4 ai4d4 = ai4 / 4;
                const uvec4 ai4m4 = ai4 % 4;

                a.r = buffer_ld4(A_blob_data, ai4d4.r)[ai4m4.r];
                a.g = buffer_ld4(A_blob_data, ai4d4.g)[ai4m4.g];
                a.b = buffer_ld4(A_blob_data, ai4d4.b)[ai4m4.b];
                a.a = buffer_ld4(A_blob_data, ai4d4.a)[ai4m4.a];
            }
        }
        else
        {
            const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);
            const uvec4 ai4 = gy4 * p.A_hstep + k;

            const uvec4 ai4d4 = ai4 / 4;
            const uvec4 ai4m4 = ai4 % 4;

            a.r = buffer_ld4(A_blob_data, ai4d4.r)[ai4m4.r];
            a.g = buffer_ld4(A_blob_data, ai4d4.g)[ai4m4.g];
            a.b = buffer_ld4(A_blob_data, ai4d4.b)[ai4m4.b];
            a.a = buffer_ld4(A_blob_data, ai4d4.a)[ai4m4.a];
        }

        afpvec4 b;
        if (transB == 1)
        {
            const uvec4 gx4 = gx * 4 + uvec4(0, 1, 2, 3);
            const uvec4 bi4 = gx4 * p.B_hstep + k;

            const uvec4 bi4d4 = bi4 / 4;
            const uvec4 bi4m4 = bi4 % 4;

            b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
            b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
            b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
            b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];
        }
        else
        {
            if (p.B_hstep % 4 == 0)
            {
                const uint bi = k * (p.B_hstep / 4) + gx;
                b = buffer_ld4(B_blob_data, bi);
            }
            else
            {
                const uvec4 bi4 = k * p.B_hstep + gx * 4 + uvec4(0, 1, 2, 3);

                const uvec4 bi4d4 = bi4 / 4;
                const uvec4 bi4m4 = bi4 % 4;

                b.r = buffer_ld4(B_blob_data, bi4d4.r)[bi4m4.r];
                b.g = buffer_ld4(B_blob_data, bi4d4.g)[bi4m4.g];
                b.b = buffer_ld4(B_blob_data, bi4d4.b)[bi4m4.b];
                b.a = buffer_ld4(B_blob_data, bi4d4.a)[bi4m4.a];
            }
        }

        sum0 += a.r * b;
        sum1 += a.g * b;
        sum2 += a.b * b;
        sum3 += a.a * b;
    }
#endif

#if NCNN_shader_local_memory
    if (gx * 4 >= psc(N) || gy * 4 >= psc(M) || gz >= 1)
        return;
#endif

    if (alpha != 1.f)
    {
        sum0 *= afp(alpha);
        sum1 *= afp(alpha);
        sum2 *= afp(alpha);
        sum3 *= afp(alpha);
    }

    if (output_transpose == 1)
    {
        const uvec4 gx4 = gx * 4 + uvec4(0, 1, 2, 3);
        const uvec4 gi4 = gx4 * p.outhstep + gy * 4;

        buffer_st1(top_blob_data, gi4.r, sum0.r);
        if (gy * 4 + 1 < psc(M)) buffer_st1(top_blob_data, gi4.r + 1, sum1.r);
        if (gy * 4 + 2 < psc(M)) buffer_st1(top_blob_data, gi4.r + 2, sum2.r);
        if (gy * 4 + 3 < psc(M)) buffer_st1(top_blob_data, gi4.r + 3, sum3.r);
        if (gx4.g < psc(N))
        {
            buffer_st1(top_blob_data, gi4.g, sum0.g);
            if (gy * 4 + 1 < psc(M)) buffer_st1(top_blob_data, gi4.g + 1, sum1.g);
            if (gy * 4 + 2 < psc(M)) buffer_st1(top_blob_data, gi4.g + 2, sum2.g);
            if (gy * 4 + 3 < psc(M)) buffer_st1(top_blob_data, gi4.g + 3, sum3.g);
        }
        if (gx4.b < psc(N))
        {
            buffer_st1(top_blob_data, gi4.b, sum0.b);
            if (gy * 4 + 1 < psc(M)) buffer_st1(top_blob_data, gi4.b + 1, sum1.b);
            if (gy * 4 + 2 < psc(M)) buffer_st1(top_blob_data, gi4.b + 2, sum2.b);
            if (gy * 4 + 3 < psc(M)) buffer_st1(top_blob_data, gi4.b + 3, sum3.b);
        }
        if (gx4.a < psc(N))
        {
            buffer_st1(top_blob_data, gi4.a, sum0.a);
            if (gy * 4 + 1 < psc(M)) buffer_st1(top_blob_data, gi4.a + 1, sum1.a);
            if (gy * 4 + 2 < psc(M)) buffer_st1(top_blob_data, gi4.a + 2, sum2.a);
            if (gy * 4 + 3 < psc(M)) buffer_st1(top_blob_data, gi4.a + 3, sum3.a);
        }
    }
    else
    {
        const uvec4 gy4 = gy * 4 + uvec4(0, 1, 2, 3);
        const uvec4 gi4 = gy4 * p.outhstep + gx * 4;

        buffer_st1(top_blob_data, gi4.r, sum0.r);
        if (gx * 4 + 1 < psc(N)) buffer_st1(top_blob_data, gi4.r + 1, sum0.g);
        if (gx * 4 + 2 < psc(N)) buffer_st1(top_blob_data, gi4.r + 2, sum0.b);
        if (gx * 4 + 3 < psc(N)) buffer_st1(top_blob_data, gi4.r + 3, sum0.a);
        if (gy4.g < psc(M))
        {
            buffer_st1(top_blob_data, gi4.g, sum1.r);
            if (gx * 4 + 1 < psc(N)) buffer_st1(top_blob_data, gi4.g + 1, sum1.g);
            if (gx * 4 + 2 < psc(N)) buffer_st1(top_blob_data, gi4.g + 2, sum1.b);
            if (gx * 4 + 3 < psc(N)) buffer_st1(top_blob_data, gi4.g + 3, sum1.a);
        }
        if (gy4.b < psc(M))
        {
            buffer_st1(top_blob_data, gi4.b, sum2.r);
            if (gx * 4 + 1 < psc(N)) buffer_st1(top_blob_data, gi4.b + 1, sum2.g);
            if (gx * 4 + 2 < psc(N)) buffer_st1(top_blob_data, gi4.b + 2, sum2.b);
            if (gx * 4 + 3 < psc(N)) buffer_st1(top_blob_data, gi4.b + 3, sum2.a);
        }
        if (gy4.a < psc(M))
        {
            buffer_st1(top_blob_data, gi4.a, sum3.r);
            if (gx * 4 + 1 < psc(N)) buffer_st1(top_blob_data, gi4.a + 1, sum3.g);
            if (gx * 4 + 2 < psc(N)) buffer_st1(top_blob_data, gi4.a + 2, sum3.b);
            if (gx * 4 + 3 < psc(N)) buffer_st1(top_blob_data, gi4.a + 3, sum3.a);
        }
    }
}
