// Tencent is pleased to support the open source community by making ncnn available.
//
// Copyright (C) 2025 THL A29 Limited, a Tencent company. All rights reserved.
//
// Licensed under the BSD 3-Clause License (the "License"); you may not use this file except
// in compliance with the License. You may obtain a copy of the License at
//
// https://opensource.org/licenses/BSD-3-Clause
//
// Unless required by applicable law or agreed to in writing, software distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

#version 450

#extension GL_GOOGLE_include_directive: enable
#include "vulkan_activation.comp"

#extension GL_KHR_memory_scope_semantics: require
#extension GL_EXT_shader_explicit_arithmetic_types: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#if ncnn_VK_KHR_cooperative_matrix
#extension GL_KHR_cooperative_matrix: require
#elif ncnn_VK_NV_cooperative_matrix
#extension GL_NV_cooperative_matrix: require
#endif

layout (constant_id = 0) const int bias_term = 0;
layout (constant_id = 1) const int activation_type = 0;
layout (constant_id = 2) const float activation_param_0 = 0;
layout (constant_id = 3) const float activation_param_1 = 0;

layout (constant_id = 4) const int M = 0;
layout (constant_id = 5) const int N = 0;
layout (constant_id = 6) const int K = 0;

layout (constant_id = 7) const int elempack = 0;
layout (constant_id = 8) const int out_elempack = 0;

#define shape_constant_id_offset 9
layout (constant_id = shape_constant_id_offset + 0) const int w = 0;
layout (constant_id = shape_constant_id_offset + 1) const int c = 0;
layout (constant_id = shape_constant_id_offset + 2) const int cstep = 0;
layout (constant_id = shape_constant_id_offset + 3) const int outc = 0;
layout (constant_id = shape_constant_id_offset + 4) const int outcstep = 0;

layout (binding = 0) readonly buffer bottom_blob { sfp bottom_blob_data[]; };
layout (binding = 1) writeonly buffer top_blob { sfp top_blob_data[]; };
layout (binding = 2) readonly buffer weight_blob { sfp weight_data[]; };
layout (binding = 3) readonly buffer bias_blob { sfp bias_data[]; };

layout (push_constant) uniform parameter
{
    int w;
    int c;
    int cstep;
    int outc;
    int outcstep;
} p;

// #define UNROLL_INCH 4

// MxK
shared uvec2 tmp_v[M * K / 4];

// KxN
shared uvec2 tmp_k[K * N / 4];

// MxN
shared uvec2 tmp_o[M * N / 4];

void main()
{
    // FIXME hardcode
//     const uint gi = gl_GlobalInvocationID.x / 64;
    const uint gi = gl_WorkGroupID;
    const uint li = gl_LocalInvocationID.x;


    // v = (0 ... w)/M  *  (0 ... c)/K

    // w = (0 ... c)/K  *  (0 ... outc)/N

    // gi = (0 ... w)/M  *  (0 ... outc)/N

    // li = 0 1 2 3 .... 31

    const int mm = (psc(w) + M - 1) / M;
    const int nn = (psc(outc) + N - 1) / N;
    const int kk = (psc(c) + K - 1) / K;

    if (gi >= mm * nn)
        return;

#if ncnn_VK_KHR_cooperative_matrix
    coopmat<afp, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> sum0;
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
    fcoopmatNV<16, gl_ScopeSubgroup, M, N> sum0;
#else
    fcoopmatNV<32, gl_ScopeSubgroup, M, N> sum0;
#endif
#endif

    if (bias_term == 1)
    {
#if ncnn_VK_KHR_cooperative_matrix
        coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> bias0;

        coopMatLoad(bias0, bias_data, gy, 0, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
        fcoopmatNV<16, gl_ScopeSubgroup, M, N> bias0;

        coopMatLoadNV(bias0, bias_data, gy, 0, false);
#endif

#if NCNN_fp16_arithmetic
        sum0 = bias0;
#else
#if ncnn_VK_KHR_cooperative_matrix
        sum0 = coopmat<float, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(bias0);
#elif ncnn_VK_NV_cooperative_matrix
        sum0 = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(bias0);
#endif
#endif
    }
    else
    {
#if ncnn_VK_KHR_cooperative_matrix
        sum0 = coopmat<afp, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(0.f);
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
        sum0 = fcoopmatNV<16, gl_ScopeSubgroup, M, N>(0.f);
#else
        sum0 = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(0.f);
#endif
#endif
    }

    const uint ni = (gi / mm) * N;
    const uint mi = (gi % mm) * M;

// // MxK
// shared uvec2 tmp_v[M * K / 4];
//
// // KxN
// shared uvec2 tmp_k[K * N / 4];
//
// // MxN
// shared uvec2 tmp_o[M * N / 4];

    for (int k = 0; k < kk; k++)
    {
        const uint ki = k * K;


        if (li == 0)
        {

        //  +-K-+
        //  |   |
        //  M   |
        //  |   |
        //  +---+

        // load MxK
        for (int i = 0; i < M * K; i++)
        {
            const uint gm = mi + i / K;
            const uint gk = ki + i % K;

            afp v = (gk < psc(c) && gm < psc(w)) ? buffer_ld1(bottom_blob_data, gk * psc(cstep) + gm) : afp(0.f);

            // TODO optimize me
            {
                vec2 v2 = unpackHalf2x16(tmp_v[i / 4][(i % 4) / 2]);
                v2[i % 2] = v;
                tmp_v[i / 4][(i % 4) / 2] = packHalf2x16(v2);
            }
        }

        //  +-N-+
        //  |   |
        //  K   |
        //  |   |
        //  +---+

        // load KxN
        for (int i = 0; i < K * N; i++)
        {
            const uint gk = ki + i / N;
            const uint gn = ni + i % N;

            afp v = (gn < psc(outc) && gk < psc(c)) ? buffer_ld1(weight_data, gn * psc(c) + gk) : afp(0.f);

            // TODO optimize me
            {
                vec2 v2 = unpackHalf2x16(tmp_k[i / 4][(i % 4) / 2]);
                v2[i % 2] = v;
                tmp_k[i / 4][(i % 4) / 2] = packHalf2x16(v2);
            }
        }

        }

        barrier();

        {
#if ncnn_VK_KHR_cooperative_matrix
            coopmat<float16_t, gl_ScopeSubgroup, M, K, gl_MatrixUseA> A0;
            coopMatLoad(A0, tmp_v, 0, K / 4, gl_CooperativeMatrixLayoutRowMajor);

            coopmat<float16_t, gl_ScopeSubgroup, K, N, gl_MatrixUseB> B0;
            coopMatLoad(B0, tmp_k, 0, N / 4, gl_CooperativeMatrixLayoutRowMajor);

            // sum += v * k
            sum0 = coopMatMulAdd(A0, B0, sum0);
#elif ncnn_VK_NV_cooperative_matrix
            fcoopmatNV<16, gl_ScopeSubgroup, M, K> A0;
            coopMatLoadNV(A0, tmp_v, 0, K / 4, false);

            fcoopmatNV<16, gl_ScopeSubgroup, K, N> B0;
            coopMatLoadNV(B0, tmp_k, 0, N / 4, false);

            // sum += v * k
            sum0 = coopMatMulAddNV(A0, B0, sum0);
#endif
        }

        barrier();
    }

#if ncnn_VK_KHR_cooperative_matrix
#if NCNN_fp16_arithmetic
    coopMatStore(sum0, tmp_o, 0, N / 4, gl_CooperativeMatrixLayoutRowMajor);
#else
    coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> sum0_fp16 = coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(sum0);

    coopMatStore(sum0_fp16, tmp_o, 0, N / 4, gl_CooperativeMatrixLayoutRowMajor);
#endif
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
    coopMatStoreNV(sum0, tmp_o, 0, N / 4, false);
#else
    fcoopmatNV<16, gl_ScopeSubgroup, M, N> sum0_fp16 = fcoopmatNV<16, gl_ScopeSubgroup, M, N>(sum0);

    coopMatStoreNV(sum0_fp16, tmp_o, 0, N / 4, false);
#endif
#endif

    barrier();

    if (li == 0)
    {

    //  +-N-+
    //  |   |
    //  M   |
    //  |   |
    //  +---+

    // store MxN
    for (int i = 0; i < M * N; i++)
    {
        const uint gm = mi + i / N;
        const uint gn = ni + i % N;

        if (gn < psc(outc) && gm < psc(w))
        {
            // TODO optimize me

            afp v = afp(unpackHalf2x16(tmp_o[i / 4][(i % 4) / 2])[i % 2]);

            v = activation_afp(v, activation_type, activation_param_0, activation_param_1);

            buffer_st1(bottom_blob_data, gn * psc(outcstep) + gm, v);
        }
    }

    }
}
