// Tencent is pleased to support the open source community by making ncnn available.
//
// Copyright (C) 2025 THL A29 Limited, a Tencent company. All rights reserved.
//
// Licensed under the BSD 3-Clause License (the "License"); you may not use this file except
// in compliance with the License. You may obtain a copy of the License at
//
// https://opensource.org/licenses/BSD-3-Clause
//
// Unless required by applicable law or agreed to in writing, software distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

#version 450

#extension GL_GOOGLE_include_directive: require
#include "vulkan_activation.comp"

#extension GL_EXT_control_flow_attributes: require

#extension GL_KHR_memory_scope_semantics: require
#extension GL_EXT_shader_explicit_arithmetic_types: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#if ncnn_VK_KHR_cooperative_matrix
#extension GL_KHR_cooperative_matrix: require
#elif ncnn_VK_NV_cooperative_matrix
#extension GL_NV_cooperative_matrix: require
#endif

layout (constant_id = 0) const int bias_term = 0;
layout (constant_id = 1) const int activation_type = 0;
layout (constant_id = 2) const float activation_param_0 = 0;
layout (constant_id = 3) const float activation_param_1 = 0;
layout (constant_id = 4) const uint M = 1;
layout (constant_id = 5) const uint N = 1;
layout (constant_id = 6) const uint K = 1;
layout (constant_id = 7) const uint UNROLL_M = 1;
layout (constant_id = 8) const uint UNROLL_N = 1;
layout (constant_id = 9) const uint UNROLL_K = 1;
layout (constant_id = 10) const uint inch = 1;
layout (constant_id = 11) const uint outch = 1;
layout (constant_id = 12) const uint elempack = 1;
layout (constant_id = 13) const uint out_elempack = 1;

#define shape_constant_id_offset 14
layout (constant_id = shape_constant_id_offset + 0) const uint size = 0;
layout (constant_id = shape_constant_id_offset + 1) const uint cstep = 0;
layout (constant_id = shape_constant_id_offset + 2) const uint outcstep = 0;

layout (binding = 0) readonly buffer bottom_blob { uvec2 bottom_blob_data[]; };
layout (binding = 1) writeonly buffer top_blob { uvec2 top_blob_data[]; };
layout (binding = 2) readonly buffer weight_blob { uvec2 weight_data[]; };
layout (binding = 3) readonly buffer bias_blob { uvec2 bias_data[]; };

layout (push_constant) uniform parameter
{
    uint size;
    uint cstep;
    uint outcstep;
} p;

shared uvec2 tmp_v[UNROLL_K * K > UNROLL_N * N ? UNROLL_K * UNROLL_M * M * K / 4 : UNROLL_N * UNROLL_M * M * N / 4];

shared uvec2 tmp_k[UNROLL_K * UNROLL_N * K * N / 4];

void main()
{
    const uint gi = gl_WorkGroupID.x;
    const uint li = gl_LocalInvocationID.x;

    const uint mm = (psc(size) + (M * UNROLL_M) - 1) / (M * UNROLL_M);
    const uint nn = (outch + (N * UNROLL_N) - 1) / (N * UNROLL_N);
    const uint kk = (inch + K - 1) / K;

    const uint Md4 = M / 4;
    const uint Nd4 = N / 4;
    const uint Kd4 = K / 4;

    // assert gl_WorkGroupSize.x == gl_SubgroupSize
    // but neither gl_SubgroupSize nor gl_WorkGroupSize.x is a constant
    const uint local_size = ncnn_subgroupSize;

    const uint mi = (gi / nn) * (M * UNROLL_M);
    const uint ni = (gi % nn) * (N * UNROLL_N);

    if (gi / nn >= mm)
        return;

#if ncnn_VK_KHR_cooperative_matrix
    coopmat<afp, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> sum[UNROLL_N][UNROLL_M];
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
    fcoopmatNV<16, gl_ScopeSubgroup, M, N> sum[UNROLL_N][UNROLL_M];
#else
    fcoopmatNV<32, gl_ScopeSubgroup, M, N> sum[UNROLL_N][UNROLL_M];
#endif
#endif

    if (bias_term == 1)
    {
        [[unroll]] for (uint zn = 0; zn < UNROLL_N; zn++)
        {
#if ncnn_VK_KHR_cooperative_matrix
            coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> bias;
            coopMatLoad(bias, bias_data, (ni + zn * N) / 4, 0, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
            fcoopmatNV<16, gl_ScopeSubgroup, M, N> bias;
            coopMatLoadNV(bias, bias_data, (ni + zn * N) / 4, 0, false);
#endif

#if !NCNN_fp16_arithmetic
#if ncnn_VK_KHR_cooperative_matrix
            coopmat<float, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> bias_fp32 = coopmat<float, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(bias);
#elif ncnn_VK_NV_cooperative_matrix
            fcoopmatNV<32, gl_ScopeSubgroup, M, N> bias_fp32 = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(bias);
#endif
#endif

            [[unroll]] for (uint zm = 0; zm < UNROLL_M; zm++)
            {
#if NCNN_fp16_arithmetic
                sum[zn][zm] = bias;
#else
                sum[zn][zm] = bias_fp32;
#endif
            }
        }
    }
    else
    {
        [[unroll]] for (uint zn = 0; zn < UNROLL_N; zn++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_M; zm++)
            {
#if ncnn_VK_KHR_cooperative_matrix
                sum[zn][zm] = coopmat<afp, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(0.f);
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
                sum[zn][zm] = fcoopmatNV<16, gl_ScopeSubgroup, M, N>(0.f);
#else
                sum[zn][zm] = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(0.f);
#endif
#endif
            }
        }
    }

    uint k = 0;
    for (; k + UNROLL_K - 1 < kk; k += UNROLL_K)
    {
        // load bottom_blob
        {
            if (elempack == 1)
            {
                //  +-M-+-UM+
                //  |   |   |
                //  K       |
                //  |   |   |
                //  +- -+- -+
                //  |   |   |
                //  UK      |
                //  |   |   |
                //  +---+---+

                const uint cstepd4 = psc(cstep) / 4;

                // access pattern, inner to outer
                // Md4 - UNROLL_M - K - UNROLL_K

                const uint Md4_UM_K_UK_d_localsize = (Md4 * UNROLL_M * K * UNROLL_K + local_size - 1) / local_size;
                [[unroll]] for (uint q = 0; q < Md4_UM_K_UK_d_localsize; q++)
                {
                    const uint liq = li + q * local_size;

                    const uint i = liq / (Md4 * UNROLL_M);
                    const uint j = liq % (Md4 * UNROLL_M);

                    if (i < K * UNROLL_K)
                    {
                        const uint gk = k * K + i;
                        const uint gm = mi / 4 + j;

                        uvec2 v = gk < inch && gm < cstepd4 ? bottom_blob_data[gk * cstepd4 + gm] : uvec2(0);

                        tmp_v[i * (Md4 * UNROLL_M) + j] = v;
                    }
                }
            }
            else // if (elempack == 4)
            {
                //  +-K-+-UK+
                //  |   |   |
                //  M       |
                //  |   |   |
                //  +- -+- -+
                //  |   |   |
                //  UM      |
                //  |   |   |
                //  +---+---+

                const uint inchd4 = inch / 4;

                // access pattern, inner to outer
                // M - UNROLL_M - Kd4 - UNROLL_K

                const uint M_UM_Kd4_UK_d_localsize = (M * UNROLL_M * Kd4 * UNROLL_K + local_size - 1) / local_size;
                [[unroll]] for (uint q = 0; q < M_UM_Kd4_UK_d_localsize; q++)
                {
                    const uint liq = li + q * local_size;

                    const uint j = liq / (M * UNROLL_M);
                    const uint i = liq % (M * UNROLL_M);

                    if (j < Kd4 * UNROLL_K)
                    {
                        const uint gk = k * Kd4 + j;
                        const uint gm = mi + i;

                        uvec2 v = gk < inchd4 && gm < psc(cstep) ? bottom_blob_data[gk * psc(cstep) + gm] : uvec2(0);

                        tmp_v[i * (Kd4 * UNROLL_K) + j] = v;
                    }
                }
            }
        }

        // load weight
        {
            //  +-N-+-UN+
            //  |   |   |
            //  K       |
            //  |   |   |
            //  +- -+- -+
            //  |   |   |
            //  UK      |
            //  |   |   |
            //  +---+---+

            const uint outch_p4d4 = (outch + 3) / 4;

            // access pattern, inner to outer
            // Nd4 - UNROLL_N - K - UNROLL_K

            const uint Nd4_UN_K_UK_d_localsize = (Nd4 * UNROLL_N * K * UNROLL_K + local_size - 1) / local_size;
            [[unroll]] for (uint q = 0; q < Nd4_UN_K_UK_d_localsize; q++)
            {
                const uint liq = li + q * local_size;

                const uint i = liq / (Nd4 * UNROLL_N);
                const uint j = liq % (Nd4 * UNROLL_N);

                if (i < K * UNROLL_K)
                {
                    const uint gk = k * K + i;
                    const uint gn = ni / 4 + j;

                    uvec2 v = gn < outch_p4d4 && gk < inch ? weight_data[gk * outch_p4d4 + gn] : uvec2(0);

                    tmp_k[i * (Nd4 * UNROLL_N) + j] = v;
                }
            }
        }

        barrier();

#if ncnn_VK_KHR_cooperative_matrix
        coopmat<float16_t, gl_ScopeSubgroup, M, K, gl_MatrixUseA> A[UNROLL_M];
        coopmat<float16_t, gl_ScopeSubgroup, K, N, gl_MatrixUseB> B[UNROLL_N];
#elif ncnn_VK_NV_cooperative_matrix
        fcoopmatNV<16, gl_ScopeSubgroup, M, K> A[UNROLL_M];
        fcoopmatNV<16, gl_ScopeSubgroup, K, N> B[UNROLL_N];
#endif

        [[unroll]] for (uint zk = 0; zk < UNROLL_K; zk++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_M; zm++)
            {
                if (elempack == 1)
                {
#if ncnn_VK_KHR_cooperative_matrix
                    coopMatLoad(A[zm], tmp_v, zk * (Md4 * UNROLL_M * K) + zm * Md4, Md4 * UNROLL_M, gl_CooperativeMatrixLayoutColumnMajor);
#elif ncnn_VK_NV_cooperative_matrix
                    coopMatLoadNV(A[zm], tmp_v, zk * (Md4 * UNROLL_M * K) + zm * Md4, Md4 * UNROLL_M, true);
#endif
                }
                else // if (elempack == 4)
                {
#if ncnn_VK_KHR_cooperative_matrix
                    coopMatLoad(A[zm], tmp_v, zm * (Kd4 * UNROLL_K * M) + zk * Kd4, Kd4 * UNROLL_K, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
                    coopMatLoadNV(A[zm], tmp_v, zm * (Kd4 * UNROLL_K * M) + zk * Kd4, Kd4 * UNROLL_K, false);
#endif
                }
            }

            [[unroll]] for (uint zn = 0; zn < UNROLL_N; zn++)
            {
#if ncnn_VK_KHR_cooperative_matrix
                coopMatLoad(B[zn], tmp_k, zk * (Nd4 * UNROLL_N * K) + zn * Nd4, Nd4 * UNROLL_N, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
                coopMatLoadNV(B[zn], tmp_k, zk * (Nd4 * UNROLL_N * K) + zn * Nd4, Nd4 * UNROLL_N, false);
#endif
            }

            // sum += k * v
            [[unroll]] for (uint zn = 0; zn < UNROLL_N; zn++)
            {
                [[unroll]] for (uint zm = 0; zm < UNROLL_M; zm++)
                {
#if ncnn_VK_KHR_cooperative_matrix
                    sum[zn][zm] = coopMatMulAdd(A[zm], B[zn], sum[zn][zm]);
#elif ncnn_VK_NV_cooperative_matrix
                    sum[zn][zm] = coopMatMulAddNV(A[zm], B[zn], sum[zn][zm]);
#endif
                }
            }
        }

        barrier();
    }

    for (; k < kk; k++)
    {
        const uint ki = k * K;

        // load bottom_blob
        {
            if (elempack == 1)
            {
                //  +-M-+-UM+
                //  |   |   |
                //  K       |
                //  |   |   |
                //  +---+---+

                const uint cstepd4 = psc(cstep) / 4;

                // access pattern, inner to outer
                // Md4 - UNROLL_M - K

                const uint Md4_UM_K_d_localsize = (Md4 * UNROLL_M * K + local_size - 1) / local_size;
                [[unroll]] for (uint q = 0; q < Md4_UM_K_d_localsize; q++)
                {
                    const uint liq = li + q * local_size;

                    const uint i = liq / (Md4 * UNROLL_M);
                    const uint j = liq % (Md4 * UNROLL_M);

                    if (i < K)
                    {
                        const uint gk = ki + i;
                        const uint gm = mi / 4 + j;

                        uvec2 v = gk < inch && gm < cstepd4 ? bottom_blob_data[gk * cstepd4 + gm] : uvec2(0);

                        tmp_v[i * (Md4 * UNROLL_M) + j] = v;
                    }
                }
            }
            else // if (elempack == 4)
            {
                //  +-K-+
                //  |   |
                //  M   |
                //  |   |
                //  +- -+
                //  |   |
                //  UM  |
                //  |   |
                //  +---+

                const uint inchd4 = inch / 4;

                // access pattern, inner to outer
                // M - UNROLL_M - Kd4

                const uint M_UM_Kd4_d_localsize = (M * UNROLL_M * Kd4 + local_size - 1) / local_size;
                [[unroll]] for (uint q = 0; q < M_UM_Kd4_d_localsize; q++)
                {
                    const uint liq = li + q * local_size;

                    const uint j = liq / (M * UNROLL_M);
                    const uint i = liq % (M * UNROLL_M);

                    if (j < Kd4)
                    {
                        const uint gm = mi + i;
                        const uint gk = ki / 4 + j;

                        uvec2 v = gk < inchd4 && gm < psc(cstep) ? bottom_blob_data[gk * psc(cstep) + gm] : uvec2(0);

                        tmp_v[i * Kd4 + j] = v;
                    }
                }
            }
        }

        // load weight
        {
            //  +-N-+-UN+
            //  |   |   |
            //  K       |
            //  |   |   |
            //  +---+---+

            const uint outch_p4d4 = (outch + 3) / 4;

            // access pattern, inner to outer
            // Nd4 - UNROLL_N - K

            const uint Nd4_UN_K_d_localsize = (Nd4 * UNROLL_N * K + local_size - 1) / local_size;
            [[unroll]] for (uint q = 0; q < Nd4_UN_K_d_localsize; q++)
            {
                const uint liq = li + q * local_size;

                const uint i = liq / (Nd4 * UNROLL_N);
                const uint j = liq % (Nd4 * UNROLL_N);

                if (i < K)
                {
                    const uint gk = ki + i;
                    const uint gn = ni / 4 + j;

                    uvec2 v = gn < outch_p4d4 && gk < inch ? weight_data[gk * outch_p4d4 + gn] : uvec2(0);

                    tmp_k[i * (Nd4 * UNROLL_N) + j] = v;
                }
            }
        }

        barrier();

#if ncnn_VK_KHR_cooperative_matrix
        coopmat<float16_t, gl_ScopeSubgroup, M, K, gl_MatrixUseA> A[UNROLL_M];
        coopmat<float16_t, gl_ScopeSubgroup, K, N, gl_MatrixUseB> B[UNROLL_N];
#elif ncnn_VK_NV_cooperative_matrix
        fcoopmatNV<16, gl_ScopeSubgroup, M, K> A[UNROLL_M];
        fcoopmatNV<16, gl_ScopeSubgroup, K, N> B[UNROLL_N];
#endif

        [[unroll]] for (uint zm = 0; zm < UNROLL_M; zm++)
        {
            if (elempack == 1)
            {
#if ncnn_VK_KHR_cooperative_matrix
                coopMatLoad(A[zm], tmp_v, zm * Md4, Md4 * UNROLL_M, gl_CooperativeMatrixLayoutColumnMajor);
#elif ncnn_VK_NV_cooperative_matrix
                coopMatLoadNV(A[zm], tmp_v, zm * Md4, Md4 * UNROLL_M, true);
#endif
            }
            else // if (elempack == 4)
            {
#if ncnn_VK_KHR_cooperative_matrix
                coopMatLoad(A[zm], tmp_v, zm * (Kd4 * M), Kd4, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
                coopMatLoadNV(A[zm], tmp_v, zm * (Kd4 * M), Kd4, false);
#endif
            }
        }

        [[unroll]] for (uint zn = 0; zn < UNROLL_N; zn++)
        {
#if ncnn_VK_KHR_cooperative_matrix
            coopMatLoad(B[zn], tmp_k, zn * Nd4, Nd4 * UNROLL_N, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
            coopMatLoadNV(B[zn], tmp_k, zn * Nd4, Nd4 * UNROLL_N, false);
#endif
        }

        // sum += k * v
        [[unroll]] for (uint zn = 0; zn < UNROLL_N; zn++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_M; zm++)
            {
#if ncnn_VK_KHR_cooperative_matrix
                sum[zn][zm] = coopMatMulAdd(A[zm], B[zn], sum[zn][zm]);
#elif ncnn_VK_NV_cooperative_matrix
                sum[zn][zm] = coopMatMulAddNV(A[zm], B[zn], sum[zn][zm]);
#endif
            }
        }

        barrier();
    }

    [[unroll]] for (uint zn = 0; zn < UNROLL_N; zn++)
    {
        [[unroll]] for (uint zm = 0; zm < UNROLL_M; zm++)
        {
            const uint sum_stride = out_elempack == 1 ? Md4 : Nd4;
#if ncnn_VK_KHR_cooperative_matrix
            const int sum_layout = out_elempack == 1 ? gl_CooperativeMatrixLayoutColumnMajor : gl_CooperativeMatrixLayoutRowMajor;
#if NCNN_fp16_arithmetic
            coopMatStore(sum[zn][zm], tmp_v, (zn * UNROLL_M + zm) * M * Nd4, sum_stride, sum_layout);
#else
            coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> sum_fp16 = coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(sum[zn][zm]);
            coopMatStore(sum_fp16, tmp_v, (zn * UNROLL_M + zm) * M * Nd4, sum_stride, sum_layout);
#endif
#elif ncnn_VK_NV_cooperative_matrix
            const bool sum_colmajor = out_elempack == 1 ? true : false;
#if NCNN_fp16_arithmetic
            coopMatStoreNV(sum[zn][zm], tmp_v, (zn * UNROLL_M + zm) * M * Nd4, sum_stride, sum_colmajor);
#else
            fcoopmatNV<16, gl_ScopeSubgroup, M, N> sum_fp16 = fcoopmatNV<16, gl_ScopeSubgroup, M, N>(sum[zn][zm]);
            coopMatStoreNV(sum_fp16, tmp_v, (zn * UNROLL_M + zm) * M * Nd4, sum_stride, sum_colmajor);
#endif
#endif
        }
    }

    barrier();

    // store top_blob
    {
        if (out_elempack == 1)
        {
            //  +-M-+
            //  |   |
            //  N   |
            //  |   |
            //  +---+

            const uint outcstepd4 = psc(outcstep) / 4;

            // access pattern, inner to outer
            // Md4 - UNROLL_M - N - UNROLL_N

            const uint Md4_UM_N_UN_d_localsize = (Md4 * UNROLL_M * N * UNROLL_N + local_size - 1) / local_size;
            [[unroll]] for (uint q = 0; q < Md4_UM_N_UN_d_localsize; q++)
            {
                const uint liq = li + q * local_size;

                const uint zn = liq / (Md4 * UNROLL_M * N);
                const uint zmij = liq % (Md4 * UNROLL_M * N);
                const uint i = zmij / (Md4 * UNROLL_M);
                const uint zmj = zmij % (Md4 * UNROLL_M);
                const uint zm = zmj / Md4;
                const uint j = zmj % Md4;

                const uint gn = ni + zn * N + i;
                const uint gm = (mi + zm * M) / 4 + j;

                if (zn < UNROLL_N && gn < outch && gm < outcstepd4)
                {
                    uvec2 sum = tmp_v[((zn * UNROLL_M + zm) * N + i) * Md4 + j];

                    if (activation_type == 0)
                    {
                        top_blob_data[gn * outcstepd4 + gm] = sum;
                    }
                    else
                    {
                        afpvec4 v = afpvec4(unpackHalf2x16(sum.r), unpackHalf2x16(sum.g));

                        v = activation_afpvec4(v, activation_type, activation_param_0, activation_param_1);

                        top_blob_data[gn * outcstepd4 + gm] = uvec2(packHalf2x16(vec4(v).rg), packHalf2x16(vec4(v).ba));
                    }
                }
            }
        }
        else // if (out_elempack == 4)
        {
            //  +-N-+
            //  |   |
            //  M   |
            //  |   |
            //  +---+

            const uint outchd4 = outch / 4;

            // access pattern, inner to outer
            // M - UNROLL_M - Nd4 - UNROLL_N

            const uint M_UM_Nd4_UN_d_localsize = (M * UNROLL_M * Nd4 * UNROLL_N + local_size - 1) / local_size;
            [[unroll]] for (uint q = 0; q < M_UM_Nd4_UN_d_localsize; q++)
            {
                const uint liq = li + q * local_size;

                const uint zn = liq / (M * UNROLL_M * Nd4);
                const uint zmij = liq % (M * UNROLL_M * Nd4);
                const uint j = zmij / (M * UNROLL_M);
                const uint zmi = zmij % (M * UNROLL_M);
//                 const uint zm = zmi / M;
//                 const uint i = zmi % M;

                const uint gn = (ni + zn * N) / 4 + j;
//                 const uint gm = mi + zm * M + i;
                const uint gm = mi + zmi;

                if (zn < UNROLL_N && gn < outchd4 && gm < psc(outcstep))
                {
                    uvec2 sum = tmp_v[(zn * UNROLL_M * M + zmi) * Nd4 + j];

                    if (activation_type == 0)
                    {
                        top_blob_data[gn * psc(outcstep) + gm] = sum;
                    }
                    else
                    {
                        afpvec4 v = afpvec4(unpackHalf2x16(sum.r), unpackHalf2x16(sum.g));

                        v = activation_afpvec4(v, activation_type, activation_param_0, activation_param_1);

                        top_blob_data[gn * psc(outcstep) + gm] = uvec2(packHalf2x16(vec4(v).rg), packHalf2x16(vec4(v).ba));
                    }
                }
            }
        }
    }
}
