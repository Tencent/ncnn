// Copyright 2025 Tencent
// SPDX-License-Identifier: BSD-3-Clause

#version 450

#extension GL_GOOGLE_include_directive: require
#include "vulkan_activation.comp"

#extension GL_EXT_control_flow_attributes: require

#extension GL_KHR_shader_subgroup_basic: require

#extension GL_KHR_memory_scope_semantics: require
#extension GL_EXT_shader_explicit_arithmetic_types: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#if ncnn_VK_KHR_cooperative_matrix
#extension GL_KHR_cooperative_matrix: require
#elif ncnn_VK_NV_cooperative_matrix
#extension GL_NV_cooperative_matrix: require
#endif

layout (constant_id = 0) const int bias_term = 0;
layout (constant_id = 1) const int activation_type = 0;
layout (constant_id = 2) const float activation_param_0 = 0;
layout (constant_id = 3) const float activation_param_1 = 0;
layout (constant_id = 4) const uint M = 1;
layout (constant_id = 5) const uint N = 1;
layout (constant_id = 6) const uint K = 1;
layout (constant_id = 7) const uint UNROLL_SG_M = 2;
layout (constant_id = 8) const uint UNROLL_SG_N = 2;
layout (constant_id = 9) const uint UNROLL_SG_K = 2;
layout (constant_id = 10) const uint UNROLL_WG_M = 1;
layout (constant_id = 11) const uint UNROLL_WG_N = 1;
layout (constant_id = 12) const uint inch = 1;
layout (constant_id = 13) const uint outch = 1;
layout (constant_id = 14) const uint elempack = 1;
layout (constant_id = 15) const uint out_elempack = 1;

#define shape_constant_id_offset 16
layout (constant_id = shape_constant_id_offset + 0) const uint size = 0;
layout (constant_id = shape_constant_id_offset + 1) const uint cstep = 0;
layout (constant_id = shape_constant_id_offset + 2) const uint outcstep = 0;

layout (binding = 0) readonly buffer bottom_blob { uvec2 bottom_blob_data[]; };
layout (binding = 1) writeonly buffer top_blob { uvec2 top_blob_data[]; };
layout (binding = 2) readonly buffer weight_blob { uvec2 weight_data[]; };
layout (binding = 3) readonly buffer bias_blob { uvec2 bias_data[]; };

layout (push_constant) uniform parameter
{
    uint size;
    uint cstep;
    uint outcstep;
} p;

shared uvec2 tmp_v[UNROLL_WG_M * UNROLL_SG_M * UNROLL_SG_K * M * K / 4 > UNROLL_WG_N * UNROLL_WG_M * UNROLL_SG_N * UNROLL_SG_M * M * N / 4 ? UNROLL_WG_M * UNROLL_SG_M * UNROLL_SG_K * M * K / 4 : UNROLL_WG_N * UNROLL_WG_M * UNROLL_SG_N * UNROLL_SG_M * M * N / 4];

shared uvec2 tmp_k[UNROLL_WG_N * UNROLL_SG_N * UNROLL_SG_K * K * N / 4];

// shared uvec2 tmp_o[UNROLL_WG_N * UNROLL_WG_M * UNROLL_SG_N * UNROLL_SG_M * M * N / 4];

void main()
{
    // assert gl_WorkGroupSize.x == gl_SubgroupSize
    // but neither gl_SubgroupSize nor gl_WorkGroupSize.x is a constant
    const uint local_size = ncnn_subgroupSize * UNROLL_WG_M * UNROLL_WG_N;

    // [ WG_UN * WG_UM * [ SG_UN * SG_UM * subgroup ] ]

    //                     <----WG_UN---->
    //       +---N--+-SG_UN+------+------+
    //       |      |      |      |XXXXXX|
    //       M             |       XXXX<----coopmat<M,N>
    //       |      |      |      |XXXXXX|
    //       +-- --SG0-- --+-- --SG2-- --+
    //       |      |      |      |      |
    //      SG_UM          |             |
    //       |      |      |      |      |
    //    ^  +------+--WORKGROUP--+------+
    //    |  |      |      |      |      |
    //    |  |             |             |
    //    |  |      |      |      |      |
    //  WG_UM+-- --SG1-- --+-- --SG3-- --+
    //    |  |      |      |      |      |
    //    |  |             |             |
    //    |  |      |      |      |      |
    //    v  +------+------+------+------+
    //

    const uint wgi = gl_WorkGroupID.x;
    const uint sgi = gl_SubgroupID;

    const uint wgmm = (psc(size) + M * UNROLL_SG_M * UNROLL_WG_M - 1) / (M * UNROLL_SG_M * UNROLL_WG_M);
    const uint wgnn = (outch + N * UNROLL_SG_N * UNROLL_WG_N - 1) / (N * UNROLL_SG_N * UNROLL_WG_N);

    const uint wgmi = wgi / wgnn;
    const uint wgni = wgi % wgnn;

    const uint sgmi = sgi / UNROLL_WG_N;
    const uint sgni = sgi % UNROLL_WG_N;

//     const uint mi = (wgmi * UNROLL_WG_M + sgmi) * (M * UNROLL_SG_M);
//     const uint ni = (wgni * UNROLL_WG_N + sgni) * (N * UNROLL_SG_N);

//     const uint mm = (psc(size) + M - 1) / M;
//     const uint nn = (outch + N - 1) / N;
    const uint kk = (inch + K - 1) / K;

    if (wgmi >= wgmm)
        return;

    const uint li = gl_LocalInvocationID.x;

    const uint Md4 = M / 4;
    const uint Nd4 = N / 4;
    const uint Kd4 = K / 4;

    const uint mi = wgmi * (M * UNROLL_SG_M * UNROLL_WG_M);
    const uint ni = wgni * (N * UNROLL_SG_N * UNROLL_WG_N);

//     const uint zn = si / UNROLL_SG_M;
//     const uint zm = si % UNROLL_SG_M;

//     if (li == 0)
//     NCNN_LOGE("wgmi wgni = %d   %d %d", wgi, wgmi, wgni);
//     NCNN_LOGE("sgmi sgni = %d   %d %d", li, sgmi, sgni);

#if ncnn_VK_KHR_cooperative_matrix
    coopmat<afp, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> sum[UNROLL_SG_N][UNROLL_SG_M];
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
    fcoopmatNV<16, gl_ScopeSubgroup, M, N> sum[UNROLL_SG_N][UNROLL_SG_M];
#else
    fcoopmatNV<32, gl_ScopeSubgroup, M, N> sum[UNROLL_SG_N][UNROLL_SG_M];
#endif
#endif

    if (bias_term == 1)
    {
        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
//             if (subgroupElect())
//                 NCNN_LOGE("bias = %d %d %d %d", wgi, wgni, sgni, (ni + zn * N) / 4);

#if ncnn_VK_KHR_cooperative_matrix
            coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> bias;
            coopMatLoad(bias, bias_data, (ni + (sgni * UNROLL_SG_N + zn) * N) / 4, 0, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
            fcoopmatNV<16, gl_ScopeSubgroup, M, N> bias;
            coopMatLoadNV(bias, bias_data, (ni + (sgni * UNROLL_SG_N + zn) * N) / 4, 0, false);
#endif

#if !NCNN_fp16_arithmetic
#if ncnn_VK_KHR_cooperative_matrix
            coopmat<float, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> bias_fp32 = coopmat<float, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(bias);
#elif ncnn_VK_NV_cooperative_matrix
            fcoopmatNV<32, gl_ScopeSubgroup, M, N> bias_fp32 = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(bias);
#endif
#endif

            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
#if NCNN_fp16_arithmetic
                sum[zn][zm] = bias;
#else
                sum[zn][zm] = bias_fp32;
#endif
            }
        }
    }
    else
    {
        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
#if ncnn_VK_KHR_cooperative_matrix
                sum[zn][zm] = coopmat<afp, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(0.f);
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
                sum[zn][zm] = fcoopmatNV<16, gl_ScopeSubgroup, M, N>(0.f);
#else
                sum[zn][zm] = fcoopmatNV<32, gl_ScopeSubgroup, M, N>(0.f);
#endif
#endif
            }
        }
    }

    uint k = 0;
    for (; k + UNROLL_SG_K - 1 < kk; k += UNROLL_SG_K)
    {
        const uint ki = k * K;

        #if 1
        // 9us
        // load bottom_blob
        {
            if (elempack == 1)
            {
                //        +-M-+
                //        K   |
                //        +SG_UM
                //        |   |
                //     ^  +---+
                //     |  |   |
                //   SG_UK+- -+
                //     |  |   |
                //   ^ v  +---+
                //   |    |   |
                //   |    +- -+
                //   |    |   |
                // WG_UM  +---+
                //   |    |   |
                //   |    +- -+
                //   |    |   |
                //   v    +---+

                const uint cstepd4 = psc(cstep) / 4;

                // access pattern, inner to outer
                // Md4 - UNROLL_SG_M - UNROLL_WG_M - K - UNROLL_SG_K

                const uint Md4_USGM_UWGM_K_USGK_d_localsize = (Md4 * UNROLL_SG_M * UNROLL_WG_M * K * UNROLL_SG_K + local_size - 1) / local_size;
                [[unroll]] for (uint q = 0; q < Md4_USGM_UWGM_K_USGK_d_localsize; q++)
                {
                    const uint liq = li + q * local_size;

                    const uint i = liq / (Md4 * UNROLL_SG_M * UNROLL_WG_M);
                    const uint j = liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M);

                    if (i < K * UNROLL_SG_K)
                    {
                        const uint gk = ki + i;
                        const uint gm = mi / 4 + j;

                        uvec2 v = gk < inch && gm < cstepd4 ? bottom_blob_data[gk * cstepd4 + gm] : uvec2(0);
//                         uvec2 v = uvec2(gk);

                        tmp_v[((((j / (Md4 * UNROLL_SG_M)) * UNROLL_SG_K + (i / K)) * UNROLL_SG_M + (j % (Md4 * UNROLL_SG_M)) / Md4) * K + (i % K)) * Md4 + (j % Md4)] = v;
//                         tmp_v[((j / Md4) * K + i) * Md4 + (j % Md4)] = v;
//                         tmp_v[q] = v;
                    }
                }
            }
            else // if (elempack == 4)
            {
                //        +-K-+
                //        M   |
                //        +- -+
                //      SG_UM |
                //     ^  +---+
                //     |  |   |
                //   SG_UK+- -+
                //     |  |   |
                //   ^ v  +---+
                //   |    |   |
                //   |    +- -+
                //   |    |   |
                // WG_UM  +---+
                //   |    |   |
                //   |    +- -+
                //   |    |   |
                //   v    +---+

                const uint inchd4 = inch / 4;

                // access pattern, inner to outer
                // M - UNROLL_SG_M - UNROLL_WG_M - Kd4 - UNROLL_SG_K

                const uint M_USGM_UWGM_Kd4_USGK_d_localsize = (M * UNROLL_SG_M * UNROLL_WG_M * Kd4 * UNROLL_SG_K + local_size - 1) / local_size;
                [[unroll]] for (uint q = 0; q < M_USGM_UWGM_Kd4_USGK_d_localsize; q++)
                {
                    const uint liq = li + q * local_size;

                    const uint j = liq / (M * UNROLL_SG_M * UNROLL_WG_M);
                    const uint i = liq % (M * UNROLL_SG_M * UNROLL_WG_M);

                    if (j < Kd4 * UNROLL_SG_K)
                    {
                        const uint gm = mi + i;
                        const uint gk = ki / 4 + j;

                        uvec2 v = gk < inchd4 && gm < psc(cstep) ? bottom_blob_data[gk * psc(cstep) + gm] : uvec2(0);
//                         uvec2 v = uvec2(gk);

                        tmp_v[((((i / (M * UNROLL_SG_M)) * UNROLL_SG_K + (j / Kd4)) * UNROLL_SG_M + (i % (M * UNROLL_SG_M)) / M) * M + (i % M)) * Kd4 + (j % Kd4)] = v;
//                         tmp_v[zk * (UNROLL_SG_M * UNROLL_WG_M * M * Kd4) + i * Kd4 + j] = v;
//                         tmp_v[q] = v;
                    }
                }

            }
        }
        #endif

        #if 1
        // 9us
        // load weight
        {
            //        +-N-+
            //        K   |
            //        +SG_UN
            //        |   |
            //     ^  +---+
            //     |  |   |
            //   SG_UK+- -+
            //     |  |   |
            //   ^ v  +---+
            //   |    |   |
            //   |    +- -+
            //   |    |   |
            // WG_UN  +---+
            //   |    |   |
            //   |    +- -+
            //   |    |   |
            //   v    +---+

            const uint outch_p4d4 = (outch + 3) / 4;

            // access pattern, inner to outer
            // Nd4 - UNROLL_SG_N - UNROLL_WG_N - K - UNROLL_SG_K

            const uint Nd4_USGN_UWGN_K_d_localsize = (Nd4 * UNROLL_SG_N * UNROLL_WG_N * K * UNROLL_SG_K + local_size - 1) / local_size;
            [[unroll]] for (uint q = 0; q < Nd4_USGN_UWGN_K_d_localsize; q++)
            {
                const uint liq = li + q * local_size;

                const uint i = liq / (Nd4 * UNROLL_SG_N * UNROLL_WG_N);
                const uint j = liq % (Nd4 * UNROLL_SG_N * UNROLL_WG_N);

                if (i < K * UNROLL_SG_K)
                {
                    const uint gk = ki + i;
                    const uint gn = ni / 4 + j;

                    uvec2 v = gn < outch_p4d4 && gk < inch ? weight_data[gk * outch_p4d4 + gn] : uvec2(0);
//                     uvec2 v = uvec2(gn);

                    tmp_k[((((j / (Nd4 * UNROLL_SG_N)) * UNROLL_SG_K + (i / K)) * UNROLL_SG_N + (j % (Nd4 * UNROLL_SG_N)) / Nd4) * K + (i % K)) * Nd4 + (j % Nd4)] = v;
//                     tmp_k[((j / Nd4) * K + i) * Nd4 + (j % Nd4)] = v;
//                     tmp_k[q] = v;
                }
            }
        }
        #endif

        barrier();

#if 1
#if ncnn_VK_KHR_cooperative_matrix
        coopmat<float16_t, gl_ScopeSubgroup, M, K, gl_MatrixUseA> A[UNROLL_SG_M];
        coopmat<float16_t, gl_ScopeSubgroup, K, N, gl_MatrixUseB> B[UNROLL_SG_N];
#elif ncnn_VK_NV_cooperative_matrix
        fcoopmatNV<16, gl_ScopeSubgroup, M, K> A[UNROLL_SG_M];
        fcoopmatNV<16, gl_ScopeSubgroup, K, N> B[UNROLL_SG_N];
#endif

        [[unroll]] for (uint zk = 0; zk < UNROLL_SG_K; zk++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
                if (elempack == 1)
                {
                    //        +-M-+
                    //        K   |
                    //        +SG_UM
                    //        |   |
                    //     ^  +---+
                    //     |  |   |
                    //   SG_UK+- -+
                    //     |  |   |
                    //   ^ v  +---+
                    //   |    |   |
                    //   |    +- -+
                    //   |    |   |
                    // WG_UM  +---+
                    //   |    |   |
                    //   |    +- -+
                    //   |    |   |
                    //   v    +---+

#if ncnn_VK_KHR_cooperative_matrix
                    coopMatLoad(A[zm], tmp_v, ((sgmi * UNROLL_SG_K + zk) * UNROLL_SG_M + zm) * (Md4 * K), Md4, gl_CooperativeMatrixLayoutColumnMajor);
#elif ncnn_VK_NV_cooperative_matrix
                    coopMatLoadNV(A[zm], tmp_v, ((sgmi * UNROLL_SG_K + zk) * UNROLL_SG_M + zm) * (Md4 * K), Md4, true);
#endif
                }
                else // if (elempack == 4)
                {
                    //        +-K-+
                    //        M   |
                    //        +- -+
                    //      SG_UM |
                    //     ^  +---+
                    //     |  |   |
                    //   SG_UK+- -+
                    //     |  |   |
                    //   ^ v  +---+
                    //   |    |   |
                    //   |    +- -+
                    //   |    |   |
                    // WG_UM  +---+
                    //   |    |   |
                    //   |    +- -+
                    //   |    |   |
                    //   v    +---+

#if ncnn_VK_KHR_cooperative_matrix
                    coopMatLoad(A[zm], tmp_v, ((sgmi * UNROLL_SG_K + zk) * UNROLL_SG_M + zm) * (Kd4 * M), Kd4, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
                    coopMatLoadNV(A[zm], tmp_v, ((sgmi * UNROLL_SG_K + zk) * UNROLL_SG_M + zm) * (Kd4 * M), Kd4, false);
#endif
                }
            }

            [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
            {
                //        +-N-+
                //        K   |
                //        +SG_UN
                //        |   |
                //     ^  +---+
                //     |  |   |
                //   SG_UK+- -+
                //     |  |   |
                //   ^ v  +---+
                //   |    |   |
                //   |    +- -+
                //   |    |   |
                // WG_UN  +---+
                //   |    |   |
                //   |    +- -+
                //   |    |   |
                //   v    +---+

#if ncnn_VK_KHR_cooperative_matrix
                coopMatLoad(B[zn], tmp_k, ((sgni * UNROLL_SG_K + zk) * UNROLL_SG_N + zn) * (Nd4 * K), Nd4, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
                coopMatLoadNV(B[zn], tmp_k, ((sgni * UNROLL_SG_K + zk) * UNROLL_SG_N + zn) * (Nd4 * K), Nd4, false);
#endif
            }

            // sum += k * v
            [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
            {
                [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
                {
#if ncnn_VK_KHR_cooperative_matrix
                    sum[zn][zm] = coopMatMulAdd(A[zm], B[zn], sum[zn][zm]);
#elif ncnn_VK_NV_cooperative_matrix
                    sum[zn][zm] = coopMatMulAddNV(A[zm], B[zn], sum[zn][zm]);
#endif
                }
            }
        }

        barrier();
#endif
    }

#if 1
    for (; k < kk; k++)
    {
        const uint ki = k * K;

        // load bottom_blob
        {
            if (elempack == 1)
            {
                //      +-M-+
                //      K   |
                //      +SG_UM
                //      |   |
                //   ^  +---+
                //   |  |   |
                // WG_UM+- -+
                //   |  |   |
                //   v  +---+

                const uint cstepd4 = psc(cstep) / 4;

                // access pattern, inner to outer
                // Md4 - UNROLL_SG_M - UNROLL_WG_M - K

                const uint Md4_USGM_UWGM_K_d_localsize = (Md4 * UNROLL_SG_M * UNROLL_WG_M * K + local_size - 1) / local_size;
                [[unroll]] for (uint q = 0; q < Md4_USGM_UWGM_K_d_localsize; q++)
                {
                    const uint liq = li + q * local_size;

                    const uint i = liq / (Md4 * UNROLL_SG_M * UNROLL_WG_M);
                    const uint j = liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M);


//                     const uint wm = (liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M)) / (Md4 * UNROLL_SG_M);
//                     const uint zm = ((liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M)) % (Md4 * UNROLL_SG_M)) / Md4;
//                     const uint j2 = ((liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M)) % (Md4 * UNROLL_SG_M)) % Md4;


                    if (i < K)
                    {
                        const uint gk = ki + i;
                        const uint gm = mi / 4 + j;
//                         const uint gm = mi / 4 + j2;

                        uvec2 v = gk < inch && gm < cstepd4 ? bottom_blob_data[gk * cstepd4 + gm] : uvec2(0);

                        tmp_v[((j / Md4) * K + i) * Md4 + (j % Md4)] = v;
                    }
                }
            }
            else // if (elempack == 4)
            {
                //      +-K-+
                //      M   |
                //      +- -+
                //    SG_UM |
                //   ^  +---+
                //   |  |   |
                // WG_UM+- -+
                //   |  |   |
                //   v  +---+

                const uint inchd4 = inch / 4;

                // access pattern, inner to outer
                // M - UNROLL_SG_M - UNROLL_WG_M - Kd4

                const uint M_USGM_UWGM_Kd4_d_localsize = (M * UNROLL_SG_M * UNROLL_WG_M * Kd4 + local_size - 1) / local_size;
                [[unroll]] for (uint q = 0; q < M_USGM_UWGM_Kd4_d_localsize; q++)
                {
                    const uint liq = li + q * local_size;

                    const uint j = liq / (M * UNROLL_SG_M * UNROLL_WG_M);
                    const uint i = liq % (M * UNROLL_SG_M * UNROLL_WG_M);

//                     const uint wm = (liq % (M * UNROLL_SG_M * UNROLL_WG_M)) / (M * UNROLL_SG_M);
//                     const uint zm = ((liq % (M * UNROLL_SG_M * UNROLL_WG_M)) % (M * UNROLL_SG_M)) / M;
//                     const uint i2 = ((liq % (M * UNROLL_SG_M * UNROLL_WG_M)) % (M * UNROLL_SG_M)) % M;

                    if (j < Kd4)
                    {
                        const uint gm = mi + i;
//                         const uint gm = mi + i2;
                        const uint gk = ki / 4 + j;

                        uvec2 v = gk < inchd4 && gm < psc(cstep) ? bottom_blob_data[gk * psc(cstep) + gm] : uvec2(0);

                        tmp_v[i * Kd4 + j] = v;
                    }
                }
            }
        }

        // load weight
        {
            //      +-N-+
            //      K   |
            //      +SG_UN
            //      |   |
            //   ^  +---+
            //   |  |   |
            // WG_UN+- -+
            //   |  |   |
            //   v  +---+

            const uint outch_p4d4 = (outch + 3) / 4;

            // access pattern, inner to outer
            // Nd4 - UNROLL_SG_N - UNROLL_WG_N - K

            const uint Nd4_USGN_UWGN_K_d_localsize = (Nd4 * UNROLL_SG_N * UNROLL_WG_N * K + local_size - 1) / local_size;
            [[unroll]] for (uint q = 0; q < Nd4_USGN_UWGN_K_d_localsize; q++)
            {
                const uint liq = li + q * local_size;

                const uint i = liq / (Nd4 * UNROLL_SG_N * UNROLL_WG_N);
                const uint j = liq % (Nd4 * UNROLL_SG_N * UNROLL_WG_N);

//                 const uint wn = j / (Nd4 * UNROLL_SG_N);
//                 const uint zn = (j % (Nd4 * UNROLL_SG_N)) / Nd4;

                if (i < K)
                {
                    const uint gk = ki + i;
                    const uint gn = ni / 4 + j;

                    uvec2 v = gn < outch_p4d4 && gk < inch ? weight_data[gk * outch_p4d4 + gn] : uvec2(0);

                    tmp_k[((j / Nd4) * K + i) * Nd4 + (j % Nd4)] = v;

//                     tmp_k[((wn * UNROLL_SG_N + zn) * K + i) * Nd4 + (j % Nd4)] = v;
                }
            }

//             if (li == 0)
//             {
//                 vec4 v0 = vec4(unpackHalf2x16(tmp_k[0].r), unpackHalf2x16(tmp_k[0].g));
//                 vec4 v1 = vec4(unpackHalf2x16(tmp_k[Nd4 * K].r), unpackHalf2x16(tmp_k[Nd4 * K].g));
//                 NCNN_LOGE("%d   k = %v4f  %v4f", wgi, v0, v1);
//             }
        }

        barrier();

#if ncnn_VK_KHR_cooperative_matrix
        coopmat<float16_t, gl_ScopeSubgroup, M, K, gl_MatrixUseA> A[UNROLL_SG_M];
        coopmat<float16_t, gl_ScopeSubgroup, K, N, gl_MatrixUseB> B[UNROLL_SG_N];
#elif ncnn_VK_NV_cooperative_matrix
        fcoopmatNV<16, gl_ScopeSubgroup, M, K> A[UNROLL_SG_M];
        fcoopmatNV<16, gl_ScopeSubgroup, K, N> B[UNROLL_SG_N];
#endif

        [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
        {
            if (elempack == 1)
            {
                //      +-M-+
                //      K   |
                //      +SG_UM
                //      |   |
                //   ^  +---+
                //   |  |   |
                // WG_UM+- -+
                //   |  |   |
                //   v  +---+

#if ncnn_VK_KHR_cooperative_matrix
                coopMatLoad(A[zm], tmp_v, (sgmi * UNROLL_SG_M + zm) * (Md4 * K), Md4, gl_CooperativeMatrixLayoutColumnMajor);
#elif ncnn_VK_NV_cooperative_matrix
                coopMatLoadNV(A[zm], tmp_v, (sgmi * UNROLL_SG_M + zm) * (Md4 * K), Md4, true);
#endif
            }
            else // if (elempack == 4)
            {
                //      +-K-+
                //      M   |
                //      +- -+
                //    SG_UM |
                //   ^  +---+
                //   |  |   |
                // WG_UM+- -+
                //   |  |   |
                //   v  +---+

#if ncnn_VK_KHR_cooperative_matrix
                coopMatLoad(A[zm], tmp_v, (sgmi * UNROLL_SG_M + zm) * (Kd4 * M), Kd4, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
                coopMatLoadNV(A[zm], tmp_v, (sgmi * UNROLL_SG_M + zm) * (Kd4 * M), Kd4, false);
#endif
            }
        }

        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
            //      +-N-+
            //      K   |
            //      +SG_UN
            //      |   |
            //   ^  +---+
            //   |  |   |
            // WG_UN+- -+
            //   |  |   |
            //   v  +---+

#if ncnn_VK_KHR_cooperative_matrix
            coopMatLoad(B[zn], tmp_k, (sgni * UNROLL_SG_N + zn) * (Nd4 * K), Nd4, gl_CooperativeMatrixLayoutRowMajor);
#elif ncnn_VK_NV_cooperative_matrix
            coopMatLoadNV(B[zn], tmp_k, (sgni * UNROLL_SG_N + zn) * (Nd4 * K), Nd4, false);
#endif
        }

        // sum += k * v
        [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
        {
            [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
            {
#if ncnn_VK_KHR_cooperative_matrix
                sum[zn][zm] = coopMatMulAdd(A[zm], B[zn], sum[zn][zm]);
#elif ncnn_VK_NV_cooperative_matrix
                sum[zn][zm] = coopMatMulAddNV(A[zm], B[zn], sum[zn][zm]);
#endif
            }
        }

        barrier();
    }
#endif

#if 1
    [[unroll]] for (uint zn = 0; zn < UNROLL_SG_N; zn++)
    {
        [[unroll]] for (uint zm = 0; zm < UNROLL_SG_M; zm++)
        {
            if (out_elempack == 1)
            {
                //          +-M-+
                //          N   |
                //          +SG_UM
                //          |   |
                //       ^  +---+
                //       |  |   |
                //     WG_UM+- -+
                //       |  |   |
                //     ^ v  +---+
                //     |    |   |
                //     |    +- -+
                //     |    |   |
                //   SG_UN  +- -+
                //     |    |   |
                //     |    +- -+
                //     |    |   |
                //   ^ v    +---+
                //   |      |   |
                //   |      +- -+
                //   |      |   |
                //   |      +---+
                //   |      |   |
                //   |      +- -+
                //   |      |   |
                // WG_UN    +---+
                //   |      |   |
                //   |      +- -+
                //   |      |   |
                //   |      +---+
                //   |      |   |
                //   |      +- -+
                //   |      |   |
                //   v      +---+

#if ncnn_VK_KHR_cooperative_matrix
#if NCNN_fp16_arithmetic
                coopMatStore(sum[zn][zm], tmp_v, (((sgni * UNROLL_SG_N + zn) * UNROLL_WG_M + sgmi) * UNROLL_SG_M + zm) * (Md4 * N), Md4, gl_CooperativeMatrixLayoutColumnMajor);
#else
                coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> sum_fp16 = coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(sum[zn][zm]);
                coopMatStore(sum_fp16, tmp_v, (((sgni * UNROLL_SG_N + zn) * UNROLL_WG_M + sgmi) * UNROLL_SG_M + zm) * (Md4 * N), Md4, gl_CooperativeMatrixLayoutColumnMajor);
#endif
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
                coopMatStoreNV(sum[zn][zm], tmp_v, (((sgni * UNROLL_SG_N + zn) * UNROLL_WG_M + sgmi) * UNROLL_SG_M + zm) * (Md4 * N), Md4, true);
#else
                fcoopmatNV<16, gl_ScopeSubgroup, M, N> sum_fp16 = fcoopmatNV<16, gl_ScopeSubgroup, M, N>(sum[zn][zm]);
                coopMatStoreNV(sum_fp16, tmp_v, (((sgni * UNROLL_SG_N + zn) * UNROLL_WG_M + sgmi) * UNROLL_SG_M + zm) * (Md4 * N), Md4, true);
#endif
#endif
            }
            else // if (out_elempack == 4)
            {
                //          +-N-+
                //          M   |
                //          +---+
                //        SG_UM |
                //       ^  +---+
                //       |  |   |
                //     WG_UM+---+
                //       |  |   |
                //     ^ v  +---+
                //     |    |   |
                //     |    +- -+
                //     |    |   |
                //   SG_UN  +---+
                //     |    |   |
                //     |    +---+
                //     |    |   |
                //   ^ v    +---+
                //   |      |   |
                //   |      +- -+
                //   |      |   |
                //   |      +---+
                //   |      |   |
                //   |      +---+
                //   |      |   |
                // WG_UN    +---+
                //   |      |   |
                //   |      +- -+
                //   |      |   |
                //   |      +---+
                //   |      |   |
                //   |      +---+
                //   |      |   |
                //   v      +---+

#if ncnn_VK_KHR_cooperative_matrix
#if NCNN_fp16_arithmetic
                coopMatStore(sum[zn][zm], tmp_v, (((sgni * UNROLL_SG_N + zn) * UNROLL_WG_M + sgmi) * UNROLL_SG_M + zm) * (Nd4 * M), Nd4, gl_CooperativeMatrixLayoutRowMajor);
#else
                coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator> sum_fp16 = coopmat<float16_t, gl_ScopeSubgroup, M, N, gl_MatrixUseAccumulator>(sum[zn][zm]);
                coopMatStore(sum_fp16, tmp_v, (((sgni * UNROLL_SG_N + zn) * UNROLL_WG_M + sgmi) * UNROLL_SG_M + zm) * (Nd4 * M), Nd4, gl_CooperativeMatrixLayoutRowMajor);
#endif
#elif ncnn_VK_NV_cooperative_matrix
#if NCNN_fp16_arithmetic
                coopMatStoreNV(sum[zn][zm], tmp_v, (((sgni * UNROLL_SG_N + zn) * UNROLL_WG_M + sgmi) * UNROLL_SG_M + zm) * (Nd4 * M), Nd4, false);
#else
                fcoopmatNV<16, gl_ScopeSubgroup, M, N> sum_fp16 = fcoopmatNV<16, gl_ScopeSubgroup, M, N>(sum[zn][zm]);
                coopMatStoreNV(sum_fp16, tmp_v, (((sgni * UNROLL_SG_N + zn) * UNROLL_WG_M + sgmi) * UNROLL_SG_M + zm) * (Nd4 * M), Nd4, false);
#endif
#endif
            }

        }
    }
#endif

    barrier();

#if 1
    // store top_blob
    {
        if (out_elempack == 1)
        {
            //          +-M-+
            //          N   |
            //          +SG_UM
            //          |   |
            //       ^  +---+
            //       |  |   |
            //     WG_UM+- -+
            //       |  |   |
            //     ^ v  +---+
            //     |    |   |
            //     |    +- -+
            //     |    |   |
            //   SG_UN  +- -+
            //     |    |   |
            //     |    +- -+
            //     |    |   |
            //   ^ v    +---+
            //   |      |   |
            //   |      +- -+
            //   |      |   |
            //   |      +---+
            //   |      |   |
            //   |      +- -+
            //   |      |   |
            // WG_UN    +---+
            //   |      |   |
            //   |      +- -+
            //   |      |   |
            //   |      +---+
            //   |      |   |
            //   |      +- -+
            //   |      |   |
            //   v      +---+

            const uint outcstepd4 = psc(outcstep) / 4;
//             const uint outcstepd4 = (psc(size) + 3) / 4;

            // access pattern, inner to outer
            // Md4 - UNROLL_SG_M - UNROLL_WG_M - N - UNROLL_SG_N - UNROLL_WG_N

            const uint Md4_USGM_UWGM_N_USGN_UWGN_d_localsize = (Md4 * UNROLL_SG_M * UNROLL_WG_M * N * UNROLL_SG_N * UNROLL_WG_N + local_size - 1) / local_size;
            [[unroll]] for (uint q = 0; q < Md4_USGM_UWGM_N_USGN_UWGN_d_localsize; q++)
            {
                const uint liq = li + q * local_size;

                const uint i = liq / (Md4 * UNROLL_SG_M * UNROLL_WG_M);
                const uint j = liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M);

                const uint gn = ni + i;
                const uint gm = mi / 4 + j;

//                 const uint wn = i / (N * UNROLL_SG_N);
//                 const uint zn = (i % (N * UNROLL_SG_N)) / N;
//                 const uint wm = j / (Md4 * UNROLL_SG_M);
//                 const uint zm = (j % (Md4 * UNROLL_SG_M)) / Md4;

//                 const uint wn = liq / (Md4 * UNROLL_SG_M * UNROLL_WG_M * N * UNROLL_SG_N);
//                 const uint wm = (liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M * N * UNROLL_SG_N)) / (Md4 * UNROLL_SG_M * UNROLL_SG_N * N);
//                 const uint zn = ((liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M * N * UNROLL_SG_N)) % (Md4 * UNROLL_SG_M * UNROLL_SG_N * N)) / (Md4 * UNROLL_SG_M * N);
//                 const uint zm = (((liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M * N * UNROLL_SG_N)) % (Md4 * UNROLL_SG_M * UNROLL_SG_N * N)) % (Md4 * UNROLL_SG_M * N)) / (Md4 * N);

//                 const uint i2 = ((((liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M * N * UNROLL_SG_N)) % (Md4 * UNROLL_SG_M * UNROLL_SG_N * N)) % (Md4 * UNROLL_SG_M * N)) % (Md4 * N)) / Md4;
//                 const uint j2 = ((((liq % (Md4 * UNROLL_SG_M * UNROLL_WG_M * N * UNROLL_SG_N)) % (Md4 * UNROLL_SG_M * UNROLL_SG_N * N)) % (Md4 * UNROLL_SG_M * N)) % (Md4 * N)) % Md4;

//                 if (outch == 31 && gn < outch && gm < outcstepd4)
//                         NCNN_LOGE("%d %d/%d %d  => %d %d  (%d %d)    %d %d %d %d      %d", wgi, int(sgi), gl_NumSubgroups, li, gn, gm, i, j, wn, zn, wm, zm, wn < UNROLL_WG_N && gn < outch && gm < outcstepd4);


//                 if (wn < UNROLL_WG_N && gn < outch && gm < outcstepd4)
                if (i < N * UNROLL_SG_N * UNROLL_WG_N && gn < outch && gm < outcstepd4)
                {
//                     uvec2 sum = tmp_o[ ((((i / UNROLL_WG_N) * UNROLL_SG_N + (i % UNROLL_WG_N) / UNROLL_SG_N) * UNROLL_SG_M * UNROLL_WG_M + (j / Md4)) * N + (i % N)) * Md4 + (j % Md4) ];
//                     uvec2 sum = tmp_o[(((i / N) * (UNROLL_WG_M * UNROLL_SG_N) + (j / Md4)) * N + (i % N)) * Md4 + (j % Md4)];

//                     uvec2 sum = tmp_o[((((wn * UNROLL_SG_N + zn) * UNROLL_WG_M + wm) * UNROLL_SG_M + zm) * N + (i % N)) * Md4 + (j % Md4)];
//                     uvec2 sum = tmp_o[((((wn * UNROLL_SG_N + zn) * UNROLL_WG_M + wm) * UNROLL_SG_M + zm) * N + i2) * Md4 + j2];
//                     uvec2 sum = tmp_o[((((wn * UNROLL_WG_M + wm) * UNROLL_SG_N + zn) * UNROLL_SG_M + zm) * N + i2) * Md4 + j2];

                    uvec2 sum = tmp_v[(((i / N) * (UNROLL_SG_M * UNROLL_WG_M) + (j / Md4)) * N + (i % N)) * Md4 + (j % Md4)];

                    if (activation_type == 0)
                    {
                        top_blob_data[gn * outcstepd4 + gm] = sum;
                    }
                    else
                    {
                        afpvec4 v = afpvec4(unpackHalf2x16(sum.r), unpackHalf2x16(sum.g));

//                     NCNN_LOGE("%d %d/%d %d  => %d %d  (%d %d)    %d %d %d %d      %v4f", wgi, int(sgi), gl_NumSubgroups, li, gn, gm, i, j, wn, zn, wm, zm, vec4(v));

                        v = activation_afpvec4(v, activation_type, activation_param_0, activation_param_1);

//                         if (outch == 10)
//                         v = afpvec4(sgni + 10000);

                        top_blob_data[gn * outcstepd4 + gm] = uvec2(packHalf2x16(vec4(v).rg), packHalf2x16(vec4(v).ba));
                    }
                }
            }
        }
        else // if (out_elempack == 4)
        {
            //          +-N-+
            //          M   |
            //          +---+
            //        SG_UM |
            //       ^  +---+
            //       |  |   |
            //     WG_UM+---+
            //       |  |   |
            //     ^ v  +---+
            //     |    |   |
            //     |    +- -+
            //     |    |   |
            //   SG_UN  +---+
            //     |    |   |
            //     |    +---+
            //     |    |   |
            //   ^ v    +---+
            //   |      |   |
            //   |      +- -+
            //   |      |   |
            //   |      +---+
            //   |      |   |
            //   |      +---+
            //   |      |   |
            // WG_UN    +---+
            //   |      |   |
            //   |      +- -+
            //   |      |   |
            //   |      +---+
            //   |      |   |
            //   |      +---+
            //   |      |   |
            //   v      +---+

//             if (li == 0)
//             {
// //                 uvec2 sum = tmp_o[Nd4 * M * 2];
//                 uvec2 sum = tmp_o[0];
// //                 uvec2 sum = tmp_o[Nd4 * M];
//                 vec4 v = vec4(unpackHalf2x16(sum.r), unpackHalf2x16(sum.g));
//                 NCNN_LOGE("o = %v4f", v);
//             }

            const uint outchd4 = outch / 4;

            // access pattern, inner to outer
            // M - UNROLL_SG_M - UNROLL_WG_M - Nd4 - UNROLL_SG_N - UNROLL_WG_N

            const uint M_USGM_UWGM_Nd4_USGN_UWGN_d_localsize = (M * UNROLL_SG_M * UNROLL_WG_M * Nd4 * UNROLL_SG_N * UNROLL_WG_N + local_size - 1) / local_size;
            [[unroll]] for (uint q = 0; q < M_USGM_UWGM_Nd4_USGN_UWGN_d_localsize; q++)
            {
                const uint liq = li + q * local_size;

                const uint j = liq / (M * UNROLL_SG_M * UNROLL_WG_M);
                const uint i = liq % (M * UNROLL_SG_M * UNROLL_WG_M);

                const uint gn = ni / 4 + j;
                const uint gm = mi + i;

                if (j < Nd4 * UNROLL_SG_N * UNROLL_WG_N && gn < outchd4 && gm < psc(outcstep))
                {
//                     uvec2 sum = tmp_v[(((i / M) * (UNROLL_SG_N * UNROLL_WG_N) + (j / Nd4)) * M + (i % M)) * Nd4 + (j % Nd4)];
                    uvec2 sum = tmp_v[(((j / Nd4) * (UNROLL_WG_M * UNROLL_SG_N) + (i / M)) * M + (i % M)) * Nd4 + (j % Nd4)];

                    if (activation_type == 0)
                    {
                        top_blob_data[gn * psc(outcstep) + gm] = sum;
                    }
                    else
                    {
                        afpvec4 v = afpvec4(unpackHalf2x16(sum.r), unpackHalf2x16(sum.g));

                        v = activation_afpvec4(v, activation_type, activation_param_0, activation_param_1);

//                         v = afpvec4(((i / M) * (UNROLL_SG_N * UNROLL_WG_N) + (j / Nd4)));

                        top_blob_data[gn * psc(outcstep) + gm] = uvec2(packHalf2x16(vec4(v).rg), packHalf2x16(vec4(v).ba));
                    }
                }
            }
        }
    }
#endif
}
