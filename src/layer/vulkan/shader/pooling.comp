// Copyright 2026 Futz12 <pchar.cn>
// SPDX-License-Identifier: BSD-3-Clause

#version 450

layout(constant_id = 0) const int pooling_type = 0;
layout(constant_id = 1) const int kernel_w = 0;
layout(constant_id = 2) const int kernel_h = 0;
layout(constant_id = 3) const int stride_w = 1;
layout(constant_id = 4) const int stride_h = 1;
layout(constant_id = 5) const int pad_left = 0;
layout(constant_id = 6) const int pad_right = 0;
layout(constant_id = 7) const int pad_top = 0;
layout(constant_id = 8) const int pad_bottom = 0;
layout(constant_id = 9) const int pad_mode = 0;
layout(constant_id = 10) const int avgpool_count_include_pad = 0;

#define shape_constant_id_offset 11
layout(constant_id = shape_constant_id_offset + 0) const int dims = 0;
layout(constant_id = shape_constant_id_offset + 1) const int w = 0;
layout(constant_id = shape_constant_id_offset + 2) const int h = 0;
layout(constant_id = shape_constant_id_offset + 3) const int d = 0;
layout(constant_id = shape_constant_id_offset + 4) const int c = 0;
layout(constant_id = shape_constant_id_offset + 5) const int cstep = 0;

layout(constant_id = shape_constant_id_offset + 6) const int outdims = 0;
layout(constant_id = shape_constant_id_offset + 7) const int outw = 0;
layout(constant_id = shape_constant_id_offset + 8) const int outh = 0;
layout(constant_id = shape_constant_id_offset + 9) const int outd = 0;
layout(constant_id = shape_constant_id_offset + 10) const int outc = 0;
layout(constant_id = shape_constant_id_offset + 11) const int outcstep = 0;

layout(binding = 0) readonly buffer bottom_blob { sfp bottom_blob_data[]; };
layout(binding = 1) writeonly buffer top_blob { sfp top_blob_data[]; };

layout(push_constant) uniform parameter
{
    int dims;
    int w;
    int h;
    int d;
    int c;
    int cstep;

    int outdims;
    int outw;
    int outh;
    int outd;
    int outc;
    int outcstep;
} p;

void main()
{
    int ox = int(gl_GlobalInvocationID.x);
    int oy = int(gl_GlobalInvocationID.y);
    int oz = int(gl_GlobalInvocationID.z);

    if (ox >= psc(outw) || oy >= psc(outh) || oz >= psc(outc))
        return;

    int pl;
    int pr;
    int pt;
    int pb;

    if (pad_mode == 0 || pad_mode == 1)
    {
        pl = pad_left;
        pr = pad_right;
        pt = pad_top;
        pb = pad_bottom;

        if (pad_mode == 0)
        {
            int wtail = (psc(w) + pl + pr - kernel_w) % stride_w;
            int htail = (psc(h) + pt + pb - kernel_h) % stride_h;
            if (wtail != 0) pr += stride_w - wtail;
            if (htail != 0) pb += stride_h - htail;
        }
    }
    else
    {
        int wpad = kernel_w + (psc(w) - 1) / stride_w * stride_w - psc(w);
        int hpad = kernel_h + (psc(h) - 1) / stride_h * stride_h - psc(h);
        if (wpad < 0) wpad = 0;
        if (hpad < 0) hpad = 0;

        if (pad_mode == 2)
        {
            pl = wpad / 2;
            pr = wpad - pl;
            pt = hpad / 2;
            pb = hpad - pt;
        }
        else
        {
            pl = wpad - wpad / 2;
            pr = wpad / 2;
            pt = hpad - hpad / 2;
            pb = hpad / 2;
        }
    }

    int inx0 = ox * stride_w - pl;
    int iny0 = oy * stride_h - pt;

    if (pooling_type == 0)
    {
        afp mv = afp(-3.402823466e38);

        for (int ky = 0; ky < kernel_h; ky++)
        {
            int iy = iny0 + ky;
            for (int kx = 0; kx < kernel_w; kx++)
            {
                int ix = inx0 + kx;

                if (ix < 0 || ix >= psc(w) || iy < 0 || iy >= psc(h))
                    continue;

                int si = oz * psc(cstep) + iy * psc(w) + ix;
                afp v = buffer_ld1(bottom_blob_data, si);
                mv = max(mv, v);
            }
        }

        int gi = oz * psc(outcstep) + oy * psc(outw) + ox;
        buffer_st1(top_blob_data, gi, mv);
    }
    else
    {
        afp sum = afp(0.f);

        if (avgpool_count_include_pad == 1)
        {
            for (int ky = 0; ky < kernel_h; ky++)
            {
                int iy = iny0 + ky;
                for (int kx = 0; kx < kernel_w; kx++)
                {
                    int ix = inx0 + kx;

                    if (ix < 0 || ix >= psc(w) || iy < 0 || iy >= psc(h))
                        continue;

                    int si = oz * psc(cstep) + iy * psc(w) + ix;
                    sum += buffer_ld1(bottom_blob_data, si);
                }
            }

            sum *= afp(1.f / float(kernel_w * kernel_h));
            int gi = oz * psc(outcstep) + oy * psc(outw) + ox;
            buffer_st1(top_blob_data, gi, sum);
        }
        else
        {
            int vx0 = max(0, -inx0);
            int vy0 = max(0, -iny0);
            int vx1 = min(kernel_w, psc(w) - inx0);
            int vy1 = min(kernel_h, psc(h) - iny0);

            int area = (vx1 - vx0) * (vy1 - vy0);
            if (area <= 0)
            {
                int gi = oz * psc(outcstep) + oy * psc(outw) + ox;
                buffer_st1(top_blob_data, gi, afp(0.f));
                return;
            }

            for (int ky = vy0; ky < vy1; ky++)
            {
                int iy = iny0 + ky;
                for (int kx = vx0; kx < vx1; kx++)
                {
                    int ix = inx0 + kx;
                    int si = oz * psc(cstep) + iy * psc(w) + ix;
                    sum += buffer_ld1(bottom_blob_data, si);
                }
            }

            sum *= afp(1.f / float(area));
            int gi = oz * psc(outcstep) + oy * psc(outw) + ox;
            buffer_st1(top_blob_data, gi, sum);
        }
    }
}
