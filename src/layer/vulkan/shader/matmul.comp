// Copyright 2025 Futz12 <pchar.cn>
// SPDX-License-Identifier: BSD-3-Clause

#version 450

#define LOCAL_MEMORY_UNROLL_INCH 8

layout(constant_id = 0) const int transB = 0;

layout(binding = 0) writeonly buffer top_blob { sfp top_blob_data[]; };
layout(binding = 1) readonly buffer a_blob { sfp a_blob_data[]; };
layout(binding = 2) readonly buffer b_blob { sfp b_blob_data[]; };

layout(push_constant) uniform parameter
{
    int M;
    int N;
    int K;
    int mode;

    int out_dims;
    int out_w;
    int out_h;
    int out_d;
    int out_c;
    int out_cstep;
    int out_dstep;

    int a_w;
    int a_h;
    int a_d;
    int a_c;
    int a_cstep;
    int a_dstep;

    int b_w;
    int b_h;
    int b_d;
    int b_c;
    int b_cstep;
    int b_dstep;
} p;

#if NCNN_shader_local_memory
shared lfp tmp_a[8][LOCAL_MEMORY_UNROLL_INCH][2];
shared lfp tmp_b[8][LOCAL_MEMORY_UNROLL_INCH][2];
#endif

void main()
{
    const int gx = int(gl_GlobalInvocationID.x);
    const int gy = int(gl_GlobalInvocationID.y);
    const int gz = int(gl_GlobalInvocationID.z);

    if (p.mode == 0 && p.out_dims >= 2)
    {
        if (p.out_dims == 3)
        {
            if (gz >= p.out_c) return;
        }
        else if (p.out_dims == 4)
        {
            if (gz >= p.out_c * p.out_d) return;
        }

        const int lx = int(gl_LocalInvocationID.x);
        const int ly = int(gl_LocalInvocationID.y);

        const int n0 = gx * 2;
        const int m0 = gy * 2;

        int bc = 0;
        int bd = 0;

        if (p.out_dims == 4)
        {
            bc = gz / p.out_d;
            bd = gz - bc * p.out_d;
        }
        else if (p.out_dims == 3)
        {
            bc = gz;
            bd = 0;
        }

        const int ac = (p.a_c == 1) ? 0 : bc;
        const int ad = (p.a_d == 1) ? 0 : bd;
        const int bc0 = (p.b_c == 1) ? 0 : bc;
        const int bd0 = (p.b_d == 1) ? 0 : bd;

        const int a_base = ac * p.a_cstep + ad * p.a_dstep;
        const int b_base = bc0 * p.b_cstep + bd0 * p.b_dstep;

        bool in_m0 = (m0 < p.out_h);
        bool in_m1 = (m0 + 1 < p.out_h);
        bool in_n0 = (n0 < p.out_w);
        bool in_n1 = (n0 + 1 < p.out_w);

        afp sum00 = afp(0.0);
        afp sum01 = afp(0.0);
        afp sum10 = afp(0.0);
        afp sum11 = afp(0.0);

        for (int k0 = 0; k0 < p.K; k0 += LOCAL_MEMORY_UNROLL_INCH)
        {
#if NCNN_shader_local_memory
            lfp a0 = lfp(0.0);
            lfp a1 = lfp(0.0);
            const int ak = k0 + lx;
            if (ak < p.K)
            {
                if (in_m0)
                    a0 = lfp(buffer_ld1(a_blob_data, a_base + m0 * p.a_w + ak));
                if (in_m1)
                    a1 = lfp(buffer_ld1(a_blob_data, a_base + (m0 + 1) * p.a_w + ak));
            }
            tmp_a[ly][lx][0] = a0;
            tmp_a[ly][lx][1] = a1;

            lfp b0 = lfp(0.0);
            lfp b1 = lfp(0.0);
            const int bk = k0 + ly;
            if (bk < p.K)
            {
                if (in_n0)
                {
                    int b_idx0;
                    if (transB == 0)
                        b_idx0 = b_base + bk * p.b_w + n0;
                    else
                        b_idx0 = b_base + n0 * p.b_w + bk;
                    b0 = lfp(buffer_ld1(b_blob_data, b_idx0));
                }

                if (in_n1)
                {
                    int b_idx1;
                    if (transB == 0)
                        b_idx1 = b_base + bk * p.b_w + (n0 + 1);
                    else
                        b_idx1 = b_base + (n0 + 1) * p.b_w + bk;
                    b1 = lfp(buffer_ld1(b_blob_data, b_idx1));
                }
            }
            tmp_b[lx][ly][0] = b0;
            tmp_b[lx][ly][1] = b1;

            barrier();

            // Compute 2x2 block.
            for (int kk = 0; kk < LOCAL_MEMORY_UNROLL_INCH; kk++)
            {
                const afp A0 = afp(tmp_a[ly][kk][0]);
                const afp A1 = afp(tmp_a[ly][kk][1]);
                const afp B0 = afp(tmp_b[lx][kk][0]);
                const afp B1 = afp(tmp_b[lx][kk][1]);

                sum00 = sum00 + A0 * B0;
                sum01 = sum01 + A0 * B1;
                sum10 = sum10 + A1 * B0;
                sum11 = sum11 + A1 * B1;
            }

            barrier();
#else
            for (int kk = 0; kk < LOCAL_MEMORY_UNROLL_INCH; kk++)
            {
                const int k = k0 + kk;
                if (k >= p.K)
                    break;

                afp A0 = afp(0.0);
                afp A1 = afp(0.0);
                if (in_m0) A0 = buffer_ld1(a_blob_data, a_base + m0 * p.a_w + k);
                if (in_m1) A1 = buffer_ld1(a_blob_data, a_base + (m0 + 1) * p.a_w + k);

                afp B0 = afp(0.0);
                afp B1 = afp(0.0);

                if (in_n0)
                {
                    int b_idx0;
                    if (transB == 0)
                        b_idx0 = b_base + k * p.b_w + n0;
                    else
                        b_idx0 = b_base + n0 * p.b_w + k;
                    B0 = buffer_ld1(b_blob_data, b_idx0);
                }
                if (in_n1)
                {
                    int b_idx1;
                    if (transB == 0)
                        b_idx1 = b_base + k * p.b_w + (n0 + 1);
                    else
                        b_idx1 = b_base + (n0 + 1) * p.b_w + k;
                    B1 = buffer_ld1(b_blob_data, b_idx1);
                }

                sum00 = sum00 + A0 * B0;
                sum01 = sum01 + A0 * B1;
                sum10 = sum10 + A1 * B0;
                sum11 = sum11 + A1 * B1;
            }
#endif
        }

        if (in_m0 && in_n0)
        {
            int out_index;
            if (p.out_dims == 2)
                out_index = m0 * p.out_w + n0;
            else if (p.out_dims == 3)
                out_index = gz * p.out_cstep + m0 * p.out_w + n0;
            else
                out_index = bc * p.out_cstep + bd * p.out_dstep + m0 * p.out_w + n0;

            buffer_st1(top_blob_data, out_index, sum00);
        }
        if (in_m0 && in_n1)
        {
            int out_index;
            if (p.out_dims == 2)
                out_index = m0 * p.out_w + (n0 + 1);
            else if (p.out_dims == 3)
                out_index = gz * p.out_cstep + m0 * p.out_w + (n0 + 1);
            else
                out_index = bc * p.out_cstep + bd * p.out_dstep + m0 * p.out_w + (n0 + 1);

            buffer_st1(top_blob_data, out_index, sum01);
        }
        if (in_m1 && in_n0)
        {
            int out_index;
            if (p.out_dims == 2)
                out_index = (m0 + 1) * p.out_w + n0;
            else if (p.out_dims == 3)
                out_index = gz * p.out_cstep + (m0 + 1) * p.out_w + n0;
            else
                out_index = bc * p.out_cstep + bd * p.out_dstep + (m0 + 1) * p.out_w + n0;

            buffer_st1(top_blob_data, out_index, sum10);
        }
        if (in_m1 && in_n1)
        {
            int out_index;
            if (p.out_dims == 2)
                out_index = (m0 + 1) * p.out_w + (n0 + 1);
            else if (p.out_dims == 3)
                out_index = gz * p.out_cstep + (m0 + 1) * p.out_w + (n0 + 1);
            else
                out_index = bc * p.out_cstep + bd * p.out_dstep + (m0 + 1) * p.out_w + (n0 + 1);

            buffer_st1(top_blob_data, out_index, sum11);
        }

        return;
    }

    const int x = gx;
    const int y = gy;
    const int z = gz;

    if (x >= p.out_w || y >= p.out_h)
        return;

    int bc = 0;
    int bd = 0;

    int m = 0;
    int n = 0;

    if (p.mode == 0)
    {
        n = x;
        m = y;

        if (p.out_dims == 4)
        {
            const int batch_total = p.out_c * p.out_d;
            if (z >= batch_total) return;

            bc = z / p.out_d;
            bd = z - bc * p.out_d;
        }
        else if (p.out_dims == 3)
        {
            if (z >= p.out_c) return;

            bc = z;
            bd = 0;
        }
    }
    else if (p.mode == 1)
    {
        n = x;
        m = 0;

        if (p.out_dims == 3)
        {
            if (z >= p.out_c) return;
            bc = z;
            bd = y;
        }
        else if (p.out_dims == 2)
        {
            bc = y;
            bd = 0;
        }
    }
    else
    {
        n = 0;
        m = x;

        if (p.out_dims == 3)
        {
            if (z >= p.out_c) return;
            bc = z;
            bd = y;
        }
        else if (p.out_dims == 2)
        {
            bc = y;
            bd = 0;
        }
    }

    const int ac = (p.a_c == 1) ? 0 : bc;
    const int ad = (p.a_d == 1) ? 0 : bd;
    const int bc0 = (p.b_c == 1) ? 0 : bc;
    const int bd0 = (p.b_d == 1) ? 0 : bd;

    const int a_base = ac * p.a_cstep + ad * p.a_dstep;
    const int b_base = bc0 * p.b_cstep + bd0 * p.b_dstep;

    afp sum = afp(0.0);

    for (int k = 0; k < p.K; k++)
    {
        const int a_idx = a_base + m * p.a_w + k;

        int b_idx;
        if (transB == 0)
            b_idx = b_base + k * p.b_w + n;
        else
            b_idx = b_base + n * p.b_w + k;

        const afp av = buffer_ld1(a_blob_data, a_idx);
        const afp bv = buffer_ld1(b_blob_data, b_idx);
        sum = sum + av * bv;
    }

    int out_index = 0;
    if (p.out_dims == 1)
        out_index = x;
    else if (p.out_dims == 2)
        out_index = y * p.out_w + x;
    else if (p.out_dims == 3)
        out_index = z * p.out_cstep + y * p.out_w + x;
    else
        out_index = bc * p.out_cstep + bd * p.out_dstep + y * p.out_w + x;

    buffer_st1(top_blob_data, out_index, sum);
}
