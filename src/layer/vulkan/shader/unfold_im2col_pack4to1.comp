// Copyright 2026 Futz12 <pchar.cn>
// SPDX-License-Identifier: BSD-3-Clause

#version 450

layout(binding = 0) readonly buffer src_blob { sfpvec4 src_blob_data[]; };
layout(binding = 1) writeonly buffer dst_blob { sfp dst_blob_data[]; };

layout(push_constant) uniform parameter
{
    int src_w;
    int src_h;
    int channels;
    int outw;
    int outh;
    int kernel_w;
    int kernel_h;
    int dilation_w;
    int dilation_h;
    int stride_w;
    int stride_h;
    int src_cstep;
} p;

afp lane_get(afpvec4 v, int lane)
{
    if (lane == 0) return v.x;
    if (lane == 1) return v.y;
    if (lane == 2) return v.z;
    return v.w;
}

void main()
{
    int t = int(gl_GlobalInvocationID.x);
    int r = int(gl_GlobalInvocationID.y);

    int size = p.outw * p.outh;
    int maxk = p.kernel_w * p.kernel_h;

    if (t >= size || r >= maxk * p.channels)
        return;

    int pch = r / maxk;
    int k = r - pch * maxk;

    int u = k / p.kernel_w;
    int v = k - u * p.kernel_w;

    int i = t / p.outw;
    int j = t - i * p.outw;

    int sy = u * p.dilation_h + i * p.stride_h;
    int sx = v * p.dilation_w + j * p.stride_w;

    int pch4 = pch >> 2;
    int lane_in = pch & 3;

    int si4 = pch4 * p.src_cstep + sy * p.src_w + sx;
    afpvec4 vv = buffer_ld4(src_blob_data, si4);
    afp val = lane_get(vv, lane_in);

    int di = r * size + t;
    buffer_st1(dst_blob_data, di, val);
}